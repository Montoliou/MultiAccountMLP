<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Das strategische Vermögensmanagement</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .account-basin {
            background-color: #1f2937; border: 1px solid #374151; padding: 1rem; border-radius: 0.75rem;
            text-align: center; width: 220px; height: 140px; display: flex; flex-direction: column;
            justify-content: center; align-items: center; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out; position: absolute; z-index: 10; overflow: hidden;
        }
        .flow-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; overflow: visible; }
        .flow-path { fill: none; stroke: var(--mlp-blue-1); stroke: url(#flow-gradient); stroke-linecap: round; stroke-linejoin: round; transition: opacity 0.5s, stroke-width 0.5s; opacity: 0; }
        .flow-path.active { opacity: 1; }
        .flow-path-animation { stroke: white; stroke-width: 1.5px; stroke-dasharray: 10 15; animation: flow 2s linear infinite; opacity: 0; transition: opacity 0.5s; }
        .flow-path.active + .flow-path-animation { opacity: 0.4; }
        /* Erase any underlay with background color (covers legacy grey ribbons) */
        .flow-erase {
          fill: none;
          stroke-linecap: round;
          stroke-linejoin: round;
          opacity: 1;
          pointer-events: none;
          shape-rendering: geometricPrecision;
        }
        .theme-light .flow-erase { stroke: #ffffff !important; }
        .theme-dark  .flow-erase { stroke: #111827 !important; }
        /* Light theme: full blue flows, no grey halo */
        .theme-light .flow-path { stroke: var(--mlp-blue-1) !important; filter: none; }
        .theme-light .flow-path-animation { stroke: #2f6fb2; stroke-dasharray: 8 14; opacity: .9; }
        .flow-dot { fill: #60a5fa; opacity: .95; }
        .theme-light .flow-dot { fill: var(--mlp-blue-2); }
        @keyframes flow { from { stroke-dashoffset: 0; } to { stroke-dashoffset: -25; } }
        .flow-label { position: absolute; color: #9ca3af; font-size: 0.75rem; font-weight: 500; z-index: 15; transform: translate(-50%, -130%); white-space: nowrap; transition: top 0.3s, left 0.3s; }
        /* Better readability for labels on blue rivers (light) */
        .theme-light .flow-label {
          color: var(--fg);
          background: rgba(255,255,255,.95);
          border: 1px solid var(--border);
          padding: 2px 6px;
          border-radius: 999px;
          line-height: 1.1;
          box-shadow: 0 1px 2px rgba(0,0,0,.06);
        }
        .flow-value { position: absolute; background-color: #111827; color: #d1d5db; padding: 4px 10px; border-radius: 9999px; font-size: 0.9rem; font-weight: 600; z-index: 15; border: 1px solid #4b5563; white-space: nowrap; transform: translate(-50%, -50%); transition: top 0.3s, left 0.3s; }
        .limit-line { position: absolute; width: 100%; height: 2px; left: 0; z-index: 12; }
        .limit-line span { position: absolute; right: 4px; transform: translateY(-50%); font-size: 10px; background: #1f2937; padding: 0 3px; font-weight: 500;}
        .modal { display: none; }
        .modal-active { display: flex; }
        .schutzschirm {
            fill: rgba(59, 130, 246, 0.15);
            stroke: rgba(96, 165, 250, 0.4);
            stroke-width: 2px;
            transition: opacity 0.5s;
            animation: pulse-shield 4s infinite ease-in-out;
            pointer-events: none;
        }
        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #374151; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(26px); }
        
        #printable-report { display: none; }
        @media print { body > *:not(#printable-report) { display: none !important; } #printable-report { display: block; color: #000; background: #fff; } .print-table { width: 100%; border-collapse: collapse; margin-top: 1rem; margin-bottom: 2rem; } .print-table th, .print-table td { border: 1px solid #ccc; padding: 8px; text-align: left; } .print-table th { background-color: #f2f2f2; } }
        @media print {
          /* Eigene Seite für den Finanzfluss */
          .print-finanzfluss {
            break-before: page;        /* modern */
            page-break-before: always; /* legacy */
          }
          /* Verhindert „hängende“ Überschrift am Seitenende */
          .print-finanzfluss h2 {
            break-after: avoid;
            page-break-after: avoid;
          }
        }

        /* === THEME TOKENS (Dark stays default) === */
        :root {
          --mlp-blue: #002F6C;
          --mlp-blue-1: #002F6C;  /* deep navy */
          --mlp-blue-2: #3C6AA3;  /* lighter MLP blue for shading */
          --mlp-gold: #BDA177;
        }
        .theme-dark {
          --bg: #111827;        /* body bg */
          --fg: #FFFFFF;        /* text color */
          --card: #1f2937;      /* panels */
          --border: #374151;    /* borders */
          --muted: #9ca3af;     /* secondary text */
          --accent1: #3b82f6;   /* gradient start */
          --accent2: #6366f1;   /* gradient end */
        }
        .theme-light {
          --bg: #FFFFFF;
          --fg: #111827;
          --card: #F9FAFB;
          --border: #E5E7EB;
          --muted: #6B7280;
          --accent1: var(--mlp-blue);  /* MLP Blau */
          --accent2: var(--mlp-gold);  /* MLP Gold */
        }

        /* Base background/text via CSS vars (keine Änderung an Tailwind nötig) */
        body { background: var(--bg); color: var(--fg); }

        /* Panels/Borders auf Theme heben */
        .theme-light .bg-gray-800 { background-color: var(--card) !important; }
        .theme-light .bg-gray-900 { background-color: var(--bg) !important; }
        .theme-light .border-gray-700 { border-color: var(--border) !important; }
        .theme-light .text-white { color: var(--fg) !important; }
        .theme-light .text-gray-400 { color: var(--muted) !important; }

        /* Flow labels/pills harmonisieren */
        .flow-label { color: var(--muted); }
        .flow-value { background-color: #111827; color: #d1d5db; border-color: #4b5563; }
        .theme-light .flow-value { background-color: rgba(255,255,255,0.85); border-color: var(--border); color: var(--fg); }

        /* Mini Theme Toggle (Header) */
        .mini-theme-toggle { display:inline-flex; align-items:center; gap:6px; font-size:12px; color: var(--muted); }
        .mini-theme-switch { position: relative; width: 34px; height: 18px; display:inline-block; }
        .mini-theme-switch input { opacity: 0; width: 0; height: 0; }
        .mini-theme-slider { position:absolute; inset:0; background:#374151; border-radius: 999px; transition:.25s; }
        .mini-theme-slider:before { content:""; position:absolute; width:14px; height:14px; left:2px; top:2px; background:#fff; border-radius:50%; transition:.25s; }
        .theme-light .mini-theme-slider { background:#cbd5e1; }
        .mini-theme-switch input:checked + .mini-theme-slider { background: var(--mlp-blue); }
        .mini-theme-switch input:checked + .mini-theme-slider:before { transform: translateX(16px); }

        /* -------- Light Theme Polish & Overrides -------- */
        /* Inputs & selects */
        .theme-light input[type="number"],
        .theme-light input[type="text"],
        .theme-light input[type="range"],
        .theme-light select,
        .theme-light textarea {
          background: #ffffff !important;
          color: #111827 !important;
          border-color: var(--border) !important;
        }
        .theme-light .bg-gray-700 { background-color: #ffffff !important; }
        .theme-light .text-gray-300 { color: #374151 !important; }
        .theme-light .bg-gray-700 .text-gray-400,
        .theme-light .text-gray-400 { color: var(--muted) !important; }

        /* Panels / cards / modals */
        .theme-light .account-basin {
          background-color: var(--card) !important;
          border-color: var(--border) !important;
          box-shadow: 0 8px 18px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.05) !important;
        }
        .theme-light .modal .bg-gray-800 { background-color: #ffffff !important; }
        .theme-light .modal .bg-gray-900 { background-color: #ffffff !important; }
        .theme-light .border-gray-600 { border-color: var(--border) !important; }

        /* Badges / helper boxes */
        .theme-light #variant-info { background: #eef2f7 !important; color: #334155 !important; }
        .theme-light .limit-line span { background: #ffffff !important; color: #111827 !important; }

        /* Flow animation color on light */
        .theme-light .flow-path-animation { stroke: var(--mlp-blue-1); opacity: .5; }

        /* Mask strokes (define visible river area) */
        .flow-mask-stroke {
          fill: none;
          stroke: #ffffff;
          stroke-linecap: round;
          stroke-linejoin: round;
          pointer-events: none;
          shape-rendering: geometricPrecision;
        }

        /* Ensure text colors in headings/labels are dark enough */
        .theme-light h1, .theme-light h2, .theme-light h3, .theme-light label, .theme-light p { color: #111827; }
        .theme-light .text-blue-400, .theme-light .text-green-400, .theme-light .text-red-400, .theme-light .text-yellow-300 { filter: saturate(.95); }

        /* ===== UI Polish ===== */
        /* Smooth theme transitions */
        body, .account-basin, input, select, textarea, .flow-value, .flow-label {
          transition: background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
        }

        /* Light header text overrides (keeps markup unchanged) */
        .theme-light h1.text-white { color: var(--fg) !important; }
        .theme-light p.text-gray-400 { color: var(--muted) !important; }

        /* Inputs focus ring tuned to MLP blue */
        .theme-light input:focus, .theme-light select:focus, .theme-light textarea:focus {
          outline: none;
          border-color: var(--mlp-blue) !important;
          box-shadow: 0 0 0 3px rgba(0,47,108,.15);
        }

        /* Primary action hover gentle for light */
        .theme-light .bg-purple-600:hover { filter: brightness(1.05); }

        /* Print button restyle in light */
        .print-btn { transition: all .25s ease; }
        .theme-light .print-btn {
          background: #ffffff !important;
          color: #111827 !important;
          border: 1px solid #cbd5e1 !important;
        }
        .theme-light .print-btn:hover {
          background: #f8fafc !important;
          border-color: #94a3b8 !important;
        }

        /* Cards subtle separation in light */
        .theme-light .bg-gray-800 {
          box-shadow: 0 10px 24px rgba(0,0,0,.06), 0 2px 8px rgba(0,0,0,.04) !important;
        }

        /* Section dividers lighter in light */
        .theme-light hr.border-gray-700 { border-color: #e5e7eb !important; }

        /* Flow pill font weight slightly lower in light */
        .theme-light .flow-value { font-weight: 500; }
        .theme-light .flow-value {
          box-shadow: 0 1px 2px rgba(0,0,0,.06);
        }

        /* --- Ensure body flips to light despite Tailwind classes --- */
        .theme-light.bg-gray-900 { background-color: var(--bg) !important; }
        .theme-light.text-white  { color: var(--fg) !important; }

        /* --- Extra MLP accents in Light --- */
        /* Primary action becomes MLP blue in light */
        .theme-light .bg-purple-600 { background-color: var(--mlp-blue) !important; }
        .theme-light .hover\:bg-purple-700:hover { background-color: #003a84 !important; }

        /* Headings and section titles in MLP blue, yellow accents in MLP gold */
        .theme-light h1, .theme-light h2, .theme-light h3,
        .theme-light .section-title { color: var(--mlp-blue) !important; }
        .theme-light .text-yellow-300 { color: var(--mlp-gold) !important; }

        /* Light theme info badges and pills with MLP tint */
        .theme-light #variant-info { background: #e9eef6 !important; color: #0f2f55 !important; border: 1px solid #d5e0ee !important; }
        .theme-light .flow-value { border-color: #d5e0ee !important; }

        /* Inputs range track for light in subtle grey with MLP thumb */
        .theme-light input[type="range"] { background: #e5e7eb !important; }
        .theme-light input[type="range"]::-webkit-slider-thumb { background: var(--mlp-blue); }
        .theme-light input[type="range"]::-moz-range-thumb { background: var(--mlp-blue); }
        #rendite-info .text-xs { font-size: 0.7rem; }
    /* --- Print helpers for embedded images --- */
    #printable-report img { max-width: 100%; height: auto; display: block; margin: 10px auto; }
    #printable-report h1, #printable-report h2, #printable-report h3 { color: #000 !important; }
    #printable-report .muted { color: #333 !important; font-size: 12px; }
    </style>
</head>
<body class="theme-dark bg-gray-900 text-white p-4 lg:p-8 overflow-x-hidden" id="theme-root">

    <div id="main-content" class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-12">
            <h1 class="text-3xl md:text-5xl font-bold text-white mb-2">Das strategische Vermögensmanagement</h1>
            <p class="text-md md:text-lg text-gray-400">Plane deine Finanzen vom Gehalt bis zum Investment.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Input Controls -->
            <div class="w-full lg:w-1/3 lg:max-w-md">
                <div class="bg-gray-800 p-6 rounded-xl shadow-lg h-fit">
                    <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
                        <div class="flex items-center gap-3">
                             <h2 class="text-2xl font-semibold">Deine Planung</h2>
                        </div>
                        <div class="flex items-center gap-3 text-sm">
                            <!-- Mini Theme Toggle -->
                            <div class="mini-theme-toggle" title="Theme umschalten (MLP Hell / Dunkel)">
                              <span class="hidden md:inline">Hell</span>
                              <label class="mini-theme-switch">
                                <input type="checkbox" id="theme-switch" />
                                <span class="mini-theme-slider"></span>
                              </label>
                              <span class="hidden md:inline">Dunkel</span>
                            </div>

                            <!-- A/B-Variantenschalter -->
                            <span id="variante-a-label" class="font-semibold text-white">A</span>
                            <label class="switch">
                                <input type="checkbox" id="variant-switch">
                                <span class="slider"></span>
                            </label>
                            <span id="variante-b-label" class="text-gray-500">B</span>
                        </div>
                        <div class="ml-3 flex items-center gap-2 text-xs">
                          <button id="consult-toggle-btn" class="px-2 py-1 rounded border border-gray-600 hover:border-indigo-500">Beratung starten</button>
                          <button id="consult-next-btn" class="px-2 py-1 rounded bg-indigo-600 hover:bg-indigo-700 text-white hidden">Weiter</button>
                        </div>
                    </div>
                    <div id="variant-info" class="text-xs text-center text-gray-400 bg-gray-700 p-2 rounded-md mb-4"></div>
                    <div class="space-y-4">
                        <!-- Existing planning sections -->
                        <div id="sec-income">
                          <label for="income" class="block text-sm font-medium text-gray-300 mb-1">Nettoeinkommen</label>
                          <div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="income" value="3000" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div>
                        </div>
                        <hr class="border-gray-700 !my-5">
                        <h3 class="text-lg font-semibold text-yellow-300 -mb-2">Konsumkonto</h3>
                        <div id="sec-konsum">
                          <div><label for="konsumMin" class="block text-sm font-medium text-gray-300 mb-1">Mindestbestand (Sockelbetrag)</label><div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="konsumMin" value="100" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div></div>
                          <div class="mt-3"><label for="konsumLeftover" class="block text-sm font-medium text-gray-300 mb-1">Variabler Überschuss (Schätzung)</label><div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="konsumLeftover" value="250" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div></div>
                        </div>
                        <hr class="border-gray-700 !my-5">
                        <h3 class="text-lg font-semibold text-blue-300 -mb-2">Tagesgeldkonto</h3>
                        <div id="sec-tagesgeld">
                          <div><label for="tagesgeldCurrent" class="block text-sm font-medium text-gray-300 mb-1">Aktueller Stand</label><div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="tagesgeldCurrent" value="4800" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div></div>
                          <div class="mt-3"><label for="tagesgeldLimit" class="block text-sm font-medium text-gray-300 mb-1">Sparziel (Überlaufgrenze)</label><div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="tagesgeldLimit" value="5000" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div></div>
                        </div>
                        <!-- New Projection Section -->
                        <hr class="border-gray-700 !my-5">
                        <div id="sec-prognose">
                          <h3 class="text-lg font-semibold text-purple-300 -mb-2">Vermögens-Prognose</h3>
                          <div><label for="depotCurrent" class="block text-sm font-medium text-gray-300 mb-1">Aktueller Depotstand</label><div class="relative"><span class="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">€</span><input type="number" id="depotCurrent" value="25000" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-8 pr-4 py-2 focus:ring-2 focus:ring-indigo-500"></div></div>
                          <div class="mt-3">
                              <label for="anlagezeitraum" class="block text-sm font-medium text-gray-300 mb-1">Anlagezeitraum: <span id="anlagezeitraum-label" class="font-bold">15 Jahre</span></label>
                              <input type="range" id="anlagezeitraum" min="1" max="30" value="15" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                          </div>
                          <div class="mt-3">
                              <label for="rendite" class="block text-sm font-medium text-gray-300 mb-1">Ihre angenommene Rendite p.a.</label>
                              <div class="relative"><input type="number" id="rendite" step="0.1" value="7" class="w-full bg-gray-700 border border-gray-600 rounded-lg pl-4 pr-8 py-2 focus:ring-2 focus:ring-indigo-500"><span class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400">%</span></div>
                              <div id="rendite-info" class="text-xs text-gray-400 mt-2 text-center p-2 bg-gray-700 rounded-md"></div>
                          </div>
                          <button onclick="calculateProjection()" class="mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg flex justify-center items-center gap-2">
                              Prognose berechnen
                          </button>
                        </div>
                    </div>
                </div>
                 <button onclick="prepareAndPrint()" class="print-btn mt-4 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z"></path></svg>
                    Planung als PDF drucken
                </button>
            </div>

            <!-- Visualization -->
            <div id="flow-container" class="w-full lg:flex-grow relative min-h-[1150px]">
                <svg id="flow-svg" class="flow-svg">
                    <defs>
                      <linearGradient id="flow-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#3b82f6;" />
                        <stop offset="100%" style="stop-color:#6366f1;" />
                      </linearGradient>
                      <filter id="flow-glow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="3" result="blur"/>
                        <feMerge>
                          <feMergeNode in="blur"/>
                          <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                      </filter>
                      <mask id="flow-mask" maskUnits="userSpaceOnUse">
                        <rect x="0" y="0" width="100%" height="100%" fill="black"></rect>
                        <path id="flow-path-1-mask" class="flow-mask-stroke"></path>
                        <path id="flow-path-2-mask" class="flow-mask-stroke"></path>
                        <path id="konsum-tagesgeld-flow-mask" class="flow-mask-stroke"></path>
                        <path id="tagesgeld-depot-flow-mask" class="flow-mask-stroke"></path>
                        <path id="fixkosten-depot-flow-mask" class="flow-mask-stroke"></path>
                      </mask>
                    </defs>
                    <g id="flow-visuals" mask="url(#flow-mask)">
                      <path id="flow-path-1-erase" class="flow-erase"></path>
                      <path id="flow-path-1" class="flow-path"></path><path id="flow-path-1-anim" class="flow-path-animation"></path><g id="flow-path-1-dot"></g>
                      <path id="flow-path-2-erase" class="flow-erase"></path>
                      <path id="flow-path-2" class="flow-path"></path><path id="flow-path-2-anim" class="flow-path-animation"></path><g id="flow-path-2-dot"></g>
                      <path id="konsum-tagesgeld-flow-erase" class="flow-erase"></path>
                      <path id="konsum-tagesgeld-flow" class="flow-path"></path><path id="konsum-tagesgeld-flow-anim" class="flow-path-animation"></path><g id="konsum-tagesgeld-flow-dot"></g>
                      <path id="tagesgeld-depot-flow-erase" class="flow-erase"></path>
                      <path id="tagesgeld-depot-flow" class="flow-path"></path><path id="tagesgeld-depot-flow-anim" class="flow-path-animation"></path><g id="tagesgeld-depot-flow-dot"></g>
                      <path id="fixkosten-depot-flow-erase" class="flow-erase"></path>
                      <path id="fixkosten-depot-flow" class="flow-path"></path><path id="fixkosten-depot-flow-anim" class="flow-path-animation"></path><g id="fixkosten-depot-flow-dot"></g>
                    </g>
                    <path id="schutzschirm-path" class="schutzschirm"></path>
                </svg>
                <div id="gehalt-basin" class="account-basin"></div>
                <div id="fixkosten-basin" class="account-basin cursor-pointer hover:border-indigo-500" onclick="openModal('fixkosten-modal')"></div>
                <div id="konsum-basin" class="account-basin"></div>
                <div id="tagesgeld-basin" class="account-basin"></div>
                <div id="depot-basin" class="account-basin cursor-pointer hover:border-purple-500" onclick="openModal('depot-modal')"></div>
            </div>
        </div>
    </div>
    
    <div id="printable-report"></div>

    <!-- Modals -->
    <div id="prognose-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-3xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('prognose-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Prognose: Vermögensentwicklung</h3> <div class="bg-gray-900 p-4 rounded-lg"> <canvas id="prognose-chart"></canvas> </div> <div id="prognose-summary" class="mt-4 text-center"></div> </div> </div>
    <div id="fixkosten-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-2xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('fixkosten-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Fixkosten & Sparpläne</h3><div id="fixkosten-list" class="space-y-2 max-h-64 overflow-y-auto pr-2"></div> <button onclick="addFixkostenItem()" class="mt-4 text-sm bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded-md">+ Posten hinzufügen</button><hr class="border-gray-600 my-4"> <div class="flex justify-between items-center"><p class="text-lg">Monatliche Gesamtkosten:</p><p id="modal-total" class="text-2xl font-bold text-red-400">€ 0</p></div> <button onclick="saveFixkosten()" class="mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Speichern & Schließen</button> </div> </div>
    <div id="depot-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-2xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('depot-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Depot-Aufteilung</h3><p class="text-sm text-gray-400 -mt-3 mb-4">Lege fest, wie neue Investments verteilt werden.</p> <div id="depot-list" class="space-y-2 max-h-64 overflow-y-auto pr-2"></div> <button onclick="addDepotItem()" class="mt-4 text-sm bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded-md">+ Fonds hinzufügen</button><hr class="border-gray-600 my-4"> <div class="flex justify-between items-center"><p class="text-lg">Gesamt-Verteilung:</p><p id="depot-total" class="text-2xl font-bold">100 %</p></div> <p id="depot-warning" class="text-center text-yellow-400 mt-2 h-6"></p> <button id="depot-save-button" onclick="saveDepot()" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Speichern & Schließen</button> </div> </div>

    <script>
    let currentVariant = 'A';
    let fixkostenItems = [ 
        { name: 'Miete', amount: 850, interval: 'monthly', target: 'fixkosten' }, 
        { name: 'Strom', amount: 60, interval: 'monthly', target: 'fixkosten' }, 
        { name: 'Kommunikation (Handy/Netz)', amount: 40, interval: 'monthly', target: 'fixkosten' },
        { name: 'Mobilität (Auto/Ticket)', amount: 150, interval: 'monthly', target: 'fixkosten' },
        { name: 'Versicherungen', amount: 180, interval: 'quarterly', target: 'fixkosten' }, 
        { name: 'Sport/Hobbies', amount: 50, interval: 'monthly', target: 'fixkosten' },
        { name: 'Vorsorge (z.B. BU)', amount: 70, interval: 'monthly', target: 'fixkosten' },
        { name: 'Sparplan Depot', amount: 250, interval: 'monthly', target: 'depot' }, 
    ];
    let depotItems = [ { name: 'MSCI World ETF', allocation: 70, color: '#3b82f6' }, { name: 'Emerging Markets ETF', allocation: 30, color: '#8b5cf6' } ];
    let prognoseChartInstance = null;
    // Beratungsansicht state
    let consultationMode = false;      // off by default
    let consultationStep = 0;          // 0..5 per variant
    let allowDepotStream = true;       // normal mode shows depot stream

    function setConsultationMode(on) {
      consultationMode = !!on;
      consultationStep = on ? 1 : 0;
      allowDepotStream = !on; // only enable depot stream at step 5 in consultation
      applyConsultationVisibility();
      calculateAndUpdate();
      const nextBtn = getEl('consult-next-btn');
      const toggleBtn = getEl('consult-toggle-btn');
      if (on) { nextBtn.classList.remove('hidden'); toggleBtn.textContent = 'Beratung beenden'; }
      else { nextBtn.classList.add('hidden'); toggleBtn.textContent = 'Beratung starten'; }
    }

    function nextConsultationStep() {
      if (!consultationMode) return;
      consultationStep = Math.min(5, consultationStep + 1);
      if (consultationStep === 5) allowDepotStream = true; // enable depot stream only at final step
      applyConsultationVisibility();
      calculateAndUpdate();
    }

    function isVisible(el) {
      return el && el.offsetParent !== null; // hidden via CSS class will report null
    }

    function show(el, on) {
      if (!el) return;
      if (on) el.classList.remove('hidden'); else el.classList.add('hidden');
    }

    function applyConsultationVisibility() {
      const secIncome = getEl('sec-income');
      const secKonsum = getEl('sec-konsum');
      const secTG     = getEl('sec-tagesgeld');
      const secProg   = getEl('sec-prognose');

      // Default: all visible (normal mode)
      if (!consultationMode) {
        [secIncome, secKonsum, secTG, secProg].forEach(el => show(el, true));
        // all basins visible
        for (const key in basins) show(basins[key], true);
        return;
      }

      const A = (currentVariant === 'A');
      // Step visibility by variant
      if (A) {
        show(secIncome, true);
        show(secKonsum, consultationStep >= 2);
        show(secTG,     consultationStep >= 3);
        show(secProg,   consultationStep >= 4);

        show(basins.gehalt, true);
        show(basins.fixkosten, true);
        show(basins.konsum, consultationStep >= 2);
        show(basins.tagesgeld, consultationStep >= 3);
        show(basins.depot, consultationStep >= 4);
      } else {
        show(secIncome, true);
        show(secKonsum, true); // B: income + konsum from step 1
        show(secTG,     consultationStep >= 3);
        show(secProg,   consultationStep >= 4);

        show(basins.gehalt, true);
        show(basins.konsum, true);
        show(basins.fixkosten, consultationStep >= 2);
        show(basins.tagesgeld, consultationStep >= 3);
        show(basins.depot, consultationStep >= 4);
      }
    }
    
    const renditeData = {
        1: {min: -40, max: 50}, 5: {min: -12, max: 32}, 10: {min: -1.5, max: 19},
        15: {min: 3, max: 15}, 20: {min: 4, max: 13}, 25: {min: 5, max: 12}, 30: {min: 6, max: 11}
    };
    // === Load fine-grained min/max returns from TXT (MLP Renditedreieck) ===
    // File: data/rendite_extreme_generated.txt
    // Format (tab/whitespace):
    // Anlagezeitraum (Jahre)    Minimale Rendite (%)   Maximale Rendite (%)
    // 1   -42.2   51.7
    let renditeExtremes = null;

    async function loadRenditeExtremes() {
    try {
        const res = await fetch('data/rendite_extreme_generated.txt', { cache: 'no-store' });
        if (!res.ok) throw new Error('not found');
        const txt = await res.text();
        renditeExtremes = parseRenditeExtremesTSV(txt);
        // refresh UI for current slider value
        const jahre = parseInt(inputs.anlagezeitraum.value, 10);
        updateRenditeSuggestions(jahre);
    } catch (e) {
        console.warn('Rendite-Extremwerte nicht geladen, nutze Fallback.', e);
        renditeExtremes = null;
    }
    }

    function parseRenditeExtremesTSV(tsv) {
    const map = {};
    tsv.split(/\r?\n/).forEach(line => {
        const trimmed = line.trim();
        if (!trimmed) return;
        if (!/^\d+/.test(trimmed)) return; // skip header
        const parts = trimmed.split(/\t|\s+/).filter(Boolean);
        if (parts.length < 3) return;
        const years = parseInt(parts[0], 10);
        const min = parseFloat(String(parts[1]).replace(',', '.'));
        const max = parseFloat(String(parts[2]).replace(',', '.'));
        if (Number.isFinite(years) && Number.isFinite(min) && Number.isFinite(max)) {
        map[years] = { min: +min.toFixed(1), max: +max.toFixed(1) };
        }
    });
    return map;
    }

    let inputs, basins, flowContainer; // Declare globally, assign in DOMContentLoaded
    const getEl = (id) => document.getElementById(id);
    const formatCurrency = (val) => new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(val);
    const getMonthlyAmount = (item) => { const a = item.amount || 0; switch (item.interval) { case 'quarterly': return a / 3; case 'annually': return a / 12; default: return a; } };

function renderBasin(element, title, value, icon, subtext = '', { current = 0, min = 0, limit = Infinity, minScaleBase = null } = {}, specialContent = '') {
    // Fill height is only meaningful when a real capacity limit is provided
    const fillPercent = (limit > 0 && limit !== Infinity)
      ? Math.min(100, (current / limit) * 100)
      : 0;

    // The yellow minimum line can be scaled against an explicit base (minScaleBase),
    // falling back to the same limit if none provided. This allows Konsumkonto to
    // scale its Min-Linie gegen den monatlichen Überschuss statt gegen das Kartenlimit.
    const baseForMin = (minScaleBase != null && isFinite(minScaleBase) && minScaleBase > 0)
      ? minScaleBase
      : ((limit > 0 && limit !== Infinity) ? limit : null);
    const minPercent = baseForMin ? Math.min(100, (min / baseForMin) * 100) : 0;
    element.innerHTML = `
        <div class="absolute inset-0 bg-sky-500/30 rounded-lg transition-all duration-500" style="height: ${fillPercent}%; top: auto; bottom: 0;"></div>
        ${min > 0 ? `<div class="limit-line bg-yellow-500/70 border-t-2 border-dashed border-yellow-400" style="bottom: ${minPercent}%;"><span class="text-yellow-300">Min</span></div>` : ''}
        ${limit > 0 && limit !== Infinity ? `<div class="limit-line bg-green-500/70" style="bottom: 100%;"><span class="text-green-300">Max</span></div>` : ''}
        ${limit > 0 && limit !== Infinity && /Tagesgeldkonto/i.test(title) ? `<div class="absolute top-1 right-2 text-xs text-gray-400">Sparziel: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(limit)}</div>` : ''}
        <div class="relative z-10 flex flex-col items-center justify-center h-full">
          ${specialContent || icon}
          <p class="font-bold">${title}</p>
          <p class="text-lg font-mono">${value}</p>
          ${subtext ? `<p class="text-xs text-gray-400 mt-1">${subtext}</p>` : ''}
        </div>
    `;
    }

    function positionCascade() {
        if (!flowContainer) return;
        const containerWidth = flowContainer.clientWidth;
        const h_gap_side = 120;
        const v_gap = 240;
        const depotWidth = 440;
        basins.depot.style.width = `${depotWidth}px`;

        let positions;
        if (currentVariant === 'B') {
            positions = {
                gehalt:   { top: 0,          left: containerWidth / 2 - basins.gehalt.offsetWidth / 2 },
                // Karten näher zur Mitte rücken (symmetrisch)
                konsum:   { top: v_gap,      left: containerWidth / 2 - basins.konsum.offsetWidth - h_gap_side },
                fixkosten:{ top: v_gap * 2,  left: containerWidth / 2 + h_gap_side },
                tagesgeld:{ top: v_gap * 3,  left: containerWidth / 2 - basins.tagesgeld.offsetWidth / 2 },
                depot:    { top: v_gap * 4.0, left: containerWidth / 2 - depotWidth / 2 },
            };
        } else { // Variante A
            positions = {
                gehalt:   { top: 0,          left: containerWidth / 2 - basins.gehalt.offsetWidth / 2 },
                // Karten näher zur Mitte rücken (symmetrisch)
                fixkosten:{ top: v_gap,      left: containerWidth / 2 + h_gap_side },
                konsum:   { top: v_gap * 2,  left: containerWidth / 2 - basins.konsum.offsetWidth - h_gap_side },
                tagesgeld:{ top: v_gap * 3,  left: containerWidth / 2 - basins.tagesgeld.offsetWidth / 2 },
                depot:    { top: v_gap * 4.0, left: containerWidth / 2 - depotWidth / 2 },
            };
        }
        for (const key in basins) { 
            if (basins[key]) {
                basins[key].style.top = `${positions[key].top}px`; 
                basins[key].style.left = `${positions[key].left}px`; 
            }
        }
    }

    function attachFlowDot(pathId, radius = 4, speedSec = 3) {
        const dotGroupId = `${pathId}-dot`;
        let g = document.getElementById(dotGroupId);
        if (!g) {
            g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', dotGroupId);
            document.getElementById('flow-svg').appendChild(g);
        }
        // Clear existing content
        g.innerHTML = '';
        // Create circle + animateMotion referencing the path
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('class', 'flow-dot');
        circle.setAttribute('r', String(radius));
        const animateMotion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
        animateMotion.setAttribute('dur', `${Math.max(1.2, speedSec)}s`);
        animateMotion.setAttribute('repeatCount', 'indefinite');
        const mpath = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
        mpath.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', `#${pathId}`);
        animateMotion.appendChild(mpath);
        circle.appendChild(animateMotion);
        g.appendChild(circle);
    }

    function drawFlow(pathId, fromBasin, toBasin, value, maxFlowValue, labelText = '') {
        if (!fromBasin || !toBasin) return;
        const path = getEl(pathId), pathAnim = getEl(`${pathId}-anim`);
        const fromRect = fromBasin.getBoundingClientRect(), toRect = toBasin.getBoundingClientRect(), containerRect = flowContainer.getBoundingClientRect();
        let fromX = fromRect.left - containerRect.left + fromRect.width / 2;
        let fromY = fromRect.bottom - containerRect.top;
        const toX = toRect.left - containerRect.left + toRect.width / 2;
        const toY = toRect.top - containerRect.top;
        const minWidth = 10, maxWidth = 45;
        const normalizedValue = Math.max(0, value) / maxFlowValue;
        const strokeWidth = minWidth + normalizedValue * (maxWidth - minWidth);
        path.style.strokeWidth = `${value > 0 ? Math.max(minWidth, strokeWidth) : 0}px`;

        let pathData;
        // REPLACED BLOCK: custom anchor, curve, and offsets for each flow
        // --- BEGIN NEW BLOCK ---
        const EXIT_OFFSET_Y = 8; // slightly deeper anchor, hides seams better
        const CURVE_MAIN = 70;   // smaller curve radius for tighter, calmer streams
        const CURVE_SHORT = 55;  // short bends for side-to-side connections

        if (pathId === 'fixkosten-depot-flow') {
            // From right side of fixkosten into right half of depot
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.75;
            const toDepotX = toRect.left - containerRect.left + toRect.width * 0.75;
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + 70} ${toDepotX},${toY - 70} ${toDepotX},${toY}`;
        } else if (pathId === 'tagesgeld-depot-flow') {
            // From center of tagesgeld into left half of depot
            const toDepotX = toRect.left - containerRect.left + (toRect.width * 0.25);
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + 55} ${toDepotX},${toY - 55} ${toDepotX},${toY}`;
        } else if (pathId === 'konsum-tagesgeld-flow') {
            // Überschuss-Stream aus dem Konsumkonto:
            //  • Variante B: unten links aus dem Konsumkonto starten (verhindert Kreuzungen)
            //  • Variante A: unten rechts aus dem Konsumkonto starten (spiegelbildlich zur Anordnung)
            if (typeof currentVariant !== 'undefined' && currentVariant === 'B') {
                // bottom-left anchor on Konsum → Tagesgeld (zentral) mit kurzer, ruhiger Kurve
                fromX = fromRect.left - containerRect.left + fromRect.width * 0.20;
                fromY -= EXIT_OFFSET_Y;
                const c1x = fromX - 40, c1y = fromY + CURVE_SHORT;
                const c2x = toX - 20,  c2y = toY - CURVE_SHORT;
                pathData = `M ${fromX},${fromY} C ${c1x},${c1y} ${c2x},${c2y} ${toX},${toY}`;
            } else {
                // Variante A: bottom-right anchor (spiegelbildlich), kurze, sanfte Biegung
                fromX = fromRect.left - containerRect.left + fromRect.width * 0.80;
                fromY -= EXIT_OFFSET_Y;
                const c1x = fromX + 40, c1y = fromY + CURVE_SHORT;
                const c2x = toX + 20,  c2y = toY - CURVE_SHORT;
                pathData = `M ${fromX},${fromY} C ${c1x},${c1y} ${c2x},${c2y} ${toX},${toY}`;
            }
        // --- BEGIN NEW BLOCK ---
        } else if (pathId === 'flow-path-2' && typeof currentVariant !== 'undefined' && currentVariant === 'A') {
            // Dauerauftrag: from left side of Fixkosten (right column) to right side of Konsum (left column)
            const R = 65; // curve radius
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.20; // exit left
            fromY -= EXIT_OFFSET_Y;
            const toKonsumX = toRect.left - containerRect.left + toRect.width * 0.80; // enter right
            pathData = `M ${fromX},${fromY} C ${fromX - R},${fromY + R} ${toKonsumX + R},${toY - R} ${toKonsumX},${toY}`;
        } else if (pathId === 'flow-path-2' && typeof currentVariant !== 'undefined' && currentVariant === 'B') {
            // Dauerauftrag: from right side of Konsum (left column) to right-half of Fixkosten (right column)
            const R = 65; // curve radius
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.80; // exit right
            fromY -= EXIT_OFFSET_Y;
            const toRightX = toRect.left - containerRect.left + toRect.width * 0.75; // enter right half
            pathData = `M ${fromX},${fromY} C ${fromX + R},${fromY + R} ${toRightX - R},${toY - R} ${toRightX},${toY}`;
        } else {
            // Default smooth S-curve between centers
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + CURVE_MAIN} ${toX},${toY - CURVE_MAIN} ${toX},${toY}`;
        }
        // --- END NEW BLOCK ---
        path.setAttribute('d', pathData); pathAnim.setAttribute('d', pathData);

        // Update mask stroke to define visible river area
        const pathMask = getEl(`${pathId}-mask`);
        if (pathMask) {
            pathMask.setAttribute('d', pathData);
            const maskWidth = Math.max(0, parseFloat(path.style.strokeWidth || "0") + 2);
            pathMask.style.strokeWidth = `${maskWidth}px`;
        }

        // Eraser path covers any legacy underlay (stroke slightly wider than main)
        const pathErase = getEl(`${pathId}-erase`);
        if (pathErase) {
            pathErase.setAttribute('d', pathData);
            const eraseWidth = Math.max(0, parseFloat(path.style.strokeWidth || "0") + 40); // extra wide to fully cover any underlay, even at tight bends
            pathErase.style.strokeWidth = `${eraseWidth}px`;
        }

        // Add/update moving dot for direction cue
        const radius = Math.max(2, Math.min(5, parseFloat(path.style.strokeWidth) / 6));
        const speed = 6 + Math.max(0, (parseFloat(path.style.strokeWidth) - 10) / 8); // overall slower, more uniform
        attachFlowDot(pathId, radius, speed);
        
        const valueLabelId = `${pathId}-value`, textLabelId = `${pathId}-text`;
        let valueLabel = getEl(valueLabelId), textLabel = getEl(textLabelId);
        if (!valueLabel) { valueLabel = document.createElement('div'); valueLabel.className = 'flow-value'; valueLabel.id = valueLabelId; flowContainer.appendChild(valueLabel); }
        if (labelText && !textLabel) { textLabel = document.createElement('div'); textLabel.className = 'flow-label'; textLabel.id = textLabelId; flowContainer.appendChild(textLabel); }
        
        valueLabel.textContent = formatCurrency(value);
        if(textLabel) textLabel.textContent = labelText;
        const midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        valueLabel.style.left = `${midPoint.x}px`; valueLabel.style.top = `${midPoint.y}px`;
        if (textLabel) {
            textLabel.style.left = `${midPoint.x}px`;
            textLabel.style.top  = `${midPoint.y - 36}px`; // clearer separation above the amount pill
        }
        path.classList.toggle('active', value > 0);
        valueLabel.style.display = (value > 0) ? 'block' : 'none';
        if(textLabel) textLabel.style.display = (value > 0) ? 'block' : 'none';
    }

    function hideFlow(pathId) {
        const path      = getEl(pathId);
        const pathAnim  = getEl(`${pathId}-anim`);
        const valueLbl  = getEl(`${pathId}-value`);
        const textLbl   = getEl(`${pathId}-text`);
        const pathErase = getEl(`${pathId}-erase`);
        const pathMask  = getEl(`${pathId}-mask`);
        const dotGroup  = getEl(`${pathId}-dot`);
        if (path) {
            path.classList.remove('active');
            path.style.strokeWidth = '0px';
        }
        if (pathAnim) {
            pathAnim.style.opacity = '0';
        }
        if (valueLbl) valueLbl.style.display = 'none';
        if (textLbl)  textLbl.style.display  = 'none';
        if (pathErase) pathErase.style.strokeWidth = '0px';
        if (pathMask)  pathMask.style.strokeWidth  = '0px';
        if (dotGroup)  dotGroup.innerHTML = '';
    }

    function drawSchutzschirm(fromBasin, toBasin) {
        if (!fromBasin || !toBasin) return;
        const path = getEl('schutzschirm-path');
        const toRect = toBasin.getBoundingClientRect(), containerRect = flowContainer.getBoundingClientRect();
        const toLeftX = toRect.left - containerRect.left, toRightX = toRect.right - containerRect.left, toY = toRect.top - containerRect.top;
        const controlX = toLeftX + toRect.width / 2;
        const controlY = toY - 80;
        const pathData = `M ${toLeftX}, ${toY} Q ${controlX}, ${controlY} ${toRightX}, ${toY}`;
        path.setAttribute('d', pathData);
    }
    
    function calculateAndUpdate() {
        requestAnimationFrame(() => {
            positionCascade();
            const income = parseFloat(inputs.income.value) || 0, konsumMin = parseFloat(inputs.konsumMin.value) || 0, konsumLeftover = parseFloat(inputs.konsumLeftover.value) || 0;
            const tagesgeldCurrent = parseFloat(inputs.tagesgeldCurrent.value) || 0, tagesgeldLimit = parseFloat(inputs.tagesgeldLimit.value) || 0;
            const fixkostenOnlyTotal = fixkostenItems.filter(i => i.target === 'fixkosten').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
            const depotSparplanTotal = fixkostenItems.filter(i => i.target === 'depot').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
            const totalAbgang = fixkostenOnlyTotal + depotSparplanTotal;
            // Zufluss (Inflow) in das Konsumkonto zur Skalierung der Min-Linie
            const konsumInflow = (currentVariant === 'A')
              ? Math.max(0, income - totalAbgang)   // Variante A: nach Abzug aller Abgänge (Fix + Sparplan)
              : Math.max(0, income);                // Variante B: Gehalt geht direkt auf Konsum
            const { tagesgeldInflow, depotOverflow } = calculateOverflow(konsumLeftover, tagesgeldCurrent, tagesgeldLimit);
            const finalTagesgeld = tagesgeldCurrent + tagesgeldInflow;
            const totalDepotInflow = depotSparplanTotal + depotOverflow;
            
            let konsumValue;
            if(currentVariant === 'A') {
                konsumValue = income - totalAbgang;
            } else {
                konsumValue = income - totalAbgang;
            }
            
            renderBasin(basins.gehalt, 'Gehaltseingang', formatCurrency(income), '<svg class="w-7 h-7 mb-1 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>');
            renderBasin(basins.fixkosten, 'Fixkostenkonto', formatCurrency(totalAbgang), '<svg class="w-7 h-7 mb-1 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>', '(Klick zum Bearbeiten)');
            // Scale the yellow min line relative to the available monthly surplus (Überschuss).
            renderBasin(
              basins.konsum,
              'Konsumkonto',
              formatCurrency(konsumValue),
              '<svg class="w-7 h-7 mb-1 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>',
              `Überschuss: ${formatCurrency(konsumLeftover)}`,
              { current: konsumValue, min: konsumMin, limit: Infinity, minScaleBase: konsumInflow }
            );
            renderBasin(basins.tagesgeld, 'Tagesgeldkonto', formatCurrency(finalTagesgeld), '<svg class="w-7 h-7 mb-1 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path></svg>', `Zufluss: ${formatCurrency(tagesgeldInflow)}`, { current: finalTagesgeld, min: 0, limit: tagesgeldLimit });
            renderBasin(basins.depot, 'Vermögensaufbau', `+ ${formatCurrency(totalDepotInflow)}`, '', '(Klick zum Bearbeiten)', {}, createGrowthChartSVG());
            
            // === BEGIN: Flow visibility control (consultation-aware) ===
            const bothVisible = (a, b) => isVisible(a) && isVisible(b);
            const maxFlow = income || 1;

            let show1 = false, show2 = false, showKTG = false, showTGDepot = false, showFixDepot = false;

            if (currentVariant === 'A') {
                // A: Gehalt -> Fixkosten -> Konsum -> Tagesgeld -> Depot; Sparrate erst Step 5
                show1       = bothVisible(basins.gehalt,   basins.fixkosten);                                      // Step 1+
                show2       = bothVisible(basins.fixkosten, basins.konsum)   && (!consultationMode || consultationStep >= 2);
                showKTG     = bothVisible(basins.konsum,    basins.tagesgeld) && (!consultationMode || consultationStep >= 3);
                showTGDepot = bothVisible(basins.tagesgeld, basins.depot)     && (!consultationMode || consultationStep >= 4);
                showFixDepot= bothVisible(basins.fixkosten, basins.depot)     && (allowDepotStream === true); // Step 5 in consultation

                if (show1)       drawFlow('flow-path-1', basins.gehalt,    basins.fixkosten, income, maxFlow);
                else             hideFlow('flow-path-1');

                if (show2)       drawFlow('flow-path-2', basins.fixkosten, basins.konsum, Math.max(0, income - totalAbgang), maxFlow, 'Dauerauftrag');
                else             hideFlow('flow-path-2');

                if (showKTG)     drawFlow('konsum-tagesgeld-flow', basins.konsum,    basins.tagesgeld, konsumLeftover, maxFlow);
                else             hideFlow('konsum-tagesgeld-flow');

                if (showTGDepot) drawFlow('tagesgeld-depot-flow', basins.tagesgeld,  basins.depot, depotOverflow, maxFlow);
                else             hideFlow('tagesgeld-depot-flow');

                if (showFixDepot)drawFlow('fixkosten-depot-flow', basins.fixkosten,  basins.depot, depotSparplanTotal, maxFlow, 'Sparrate');
                else             hideFlow('fixkosten-depot-flow');

            } else {
                // B: Gehalt -> Konsum -> Fixkosten -> Tagesgeld -> Depot; Sparrate erst Step 5
                show1       = bothVisible(basins.gehalt,   basins.konsum);                                        // Step 1+
                show2       = bothVisible(basins.konsum,   basins.fixkosten) && (!consultationMode || consultationStep >= 2);
                showKTG     = bothVisible(basins.konsum,   basins.tagesgeld) && (!consultationMode || consultationStep >= 3);
                showTGDepot = bothVisible(basins.tagesgeld,basins.depot)    && (!consultationMode || consultationStep >= 4);
                showFixDepot= bothVisible(basins.fixkosten,basins.depot)    && (allowDepotStream === true); // Step 5 in consultation

                if (show1)       drawFlow('flow-path-1', basins.gehalt,  basins.konsum, income, maxFlow);
                else             hideFlow('flow-path-1');

                if (show2)       drawFlow('flow-path-2', basins.konsum,  basins.fixkosten, totalAbgang, maxFlow, 'Dauerauftrag');
                else             hideFlow('flow-path-2');

                if (showKTG)     drawFlow('konsum-tagesgeld-flow', basins.konsum,   basins.tagesgeld, konsumLeftover, maxFlow);
                else             hideFlow('konsum-tagesgeld-flow');

                if (showTGDepot) drawFlow('tagesgeld-depot-flow', basins.tagesgeld, basins.depot, depotOverflow, maxFlow);
                else             hideFlow('tagesgeld-depot-flow');

                if (showFixDepot)drawFlow('fixkosten-depot-flow', basins.fixkosten, basins.depot, depotSparplanTotal, maxFlow, 'Sparrate');
                else             hideFlow('fixkosten-depot-flow');
            }
            // === END: Flow visibility control ===
            drawSchutzschirm(basins.tagesgeld, basins.depot);
            // --- Shield visibility based on available liquidity on Tagesgeld, scaled by liquidity level ---
            const shield = getEl('schutzschirm-path');
            if (shield) {
                // Sichtbarkeit des Schutzschirms: sobald im Tagesgeld verwertbare Liquidität vorhanden ist
                const liquidity = Math.max(0, finalTagesgeld); // verfügbare Liquidität auf TG
                let strength = 0;
                if (isFinite(tagesgeldLimit) && tagesgeldLimit > 0) {
                    strength = Math.min(1, liquidity / tagesgeldLimit); // skaliert relativ zum Ziel
                } else {
                    strength = liquidity > 0 ? 1 : 0; // ohne Ziel: binär
                }
                if (strength > 0) {
                    // weiche Skalierung für Sichtbarkeit/Strichstärke
                    const opacity = Math.max(0.25, 0.15 + 0.85 * strength);
                    shield.style.opacity = String(opacity);
                    shield.style.strokeWidth = `${2 + 2 * strength}px`;
                } else {
                    shield.style.opacity = '0';
                }
            }
        });
    }
    
    // --- Projection Logic ---
    function calculateProjection() {
        const initialDepot = parseFloat(inputs.depotCurrent.value) || 0;
        const years = parseInt(inputs.anlagezeitraum.value, 10);
        const depotSparplanTotal = fixkostenItems.filter(i => i.target === 'depot').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
        const tagesgeldCurrent = parseFloat(inputs.tagesgeldCurrent.value) || 0;
        const tagesgeldLimit = parseFloat(inputs.tagesgeldLimit.value) || 0;
        const konsumLeftover = parseFloat(inputs.konsumLeftover.value) || 0;
        const { depotOverflow } = calculateOverflow(konsumLeftover, tagesgeldCurrent, tagesgeldLimit);
        const monthlyInvestment = depotSparplanTotal + depotOverflow;
        const dataRange = getRenditeDataForPeriod(years);
        const returnAvg = parseFloat(inputs.rendite.value) / 100;
        const returnMin = dataRange.min / 100;
        const returnMax = dataRange.max / 100;
        const dataAvg = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnAvg);
        const dataMin = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnMin);
        const dataMax = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnMax);

        displayProjectionChart({
            labels: dataAvg.labels,
            datasets: [
                { label: 'Pessimistisch', data: dataMin.capitalData, color: '#ef4444' },
                { label: 'Erwartet', data: dataAvg.capitalData, color: '#3b82f6' },
                { label: 'Optimistisch', data: dataMax.capitalData, color: '#22c55e' },
                { label: 'Einzahlungen', data: dataAvg.contributionsData, color: '#6b7280' }
            ]
        });
        const summaryEl = getEl('prognose-summary');
        summaryEl.innerHTML = `
            <p>Nach <span class="font-bold">${years} Jahren</span> könnte dein Vermögen zwischen <span class="font-bold text-red-400">${formatCurrency(dataMin.totalCapital)}</span> und <span class="font-bold text-green-400">${formatCurrency(dataMax.totalCapital)}</span> liegen.</p>
            <p>Deine erwartete Prognose liegt bei <span class="font-bold text-blue-400 text-lg">${formatCurrency(dataAvg.totalCapital)}</span>, basierend auf ${formatCurrency(dataAvg.totalContributions)} Einzahlungen.</p>
        `;
        openModal('prognose-modal');
    }
    
    function calculateCompoundInterest(initial, monthly, years, annualRate) {
        const monthlyRate = annualRate / 12;
        let totalCapital = initial;
        let totalContributions = initial;
        const labels = ['Start'];
        const capitalData = [initial];
        const contributionsData = [initial];

        for (let i = 1; i <= years; i++) {
            for (let j = 0; j < 12; j++) {
                totalCapital = totalCapital * (1 + monthlyRate) + monthly;
                totalContributions += monthly;
            }
            labels.push(`Jahr ${i}`);
            capitalData.push(totalCapital);
            contributionsData.push(totalContributions);
        }
        return { labels, capitalData, contributionsData, totalCapital, totalContributions };
    }

    function displayProjectionChart({labels, datasets}) {
        const ctx = getEl('prognose-chart').getContext('2d');
        if (prognoseChartInstance) { prognoseChartInstance.destroy(); }
        
        const chartDatasets = datasets.map(ds => {
            // Custom styling for pessimistic and optimistic
            if (ds.label === 'Pessimistisch') {
                return {
                    label: ds.label,
                    data: ds.data,
                    borderWidth: 1.5,                // dünner
                    borderColor: 'rgba(239,68,68,0.3)', // rot mit hoher Transparenz
                    borderDash: [6, 6],              // gestrichelt
                    pointRadius: 0,                  // keine Punkte
                    fill: false,
                    tension: 0.1
                };
            } else if (ds.label === 'Optimistisch') {
                return {
                    label: ds.label,
                    data: ds.data,
                    borderWidth: 1.5,                // dünner
                    borderColor: 'rgba(34,197,94,0.3)', // grün mit hoher Transparenz
                    borderDash: [6, 6],              // gestrichelt
                    pointRadius: 0,                  // keine Punkte
                    fill: false,
                    tension: 0.1
                };
            } else {
                // Erwartet (blue), Einzahlungen (gray dashed): unchanged
                return {
                    label: ds.label,
                    data: ds.data,
                    borderColor: ds.color,
                    borderDash: ds.label.includes('Einzahlungen') ? [5, 5] : [],
                    fill: false,
                    tension: 0.1
                };
            }
        });

        prognoseChartInstance = new Chart(ctx, {
            type: 'line', data: { labels: labels, datasets: chartDatasets },
            options: { responsive: true, plugins: { legend: { labels: { color: '#d1d5db' } }, tooltip: { callbacks: { label: (c) => `${c.dataset.label}: ${formatCurrency(c.raw)}` } } },
                scales: { x: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { ticks: { color: '#9ca3af', callback: (v) => formatCurrency(v) }, grid: { color: 'rgba(255,255,255,0.1)' } } }
            }
        });
    }

    // --- Other Helpers ---
    function setRendite(value) { inputs.rendite.value = value; }
    
    function getRenditeDataForPeriod(jahre) {
        const key = [1, 5, 10, 15, 20, 25, 30].reduce((prev, curr) => (Math.abs(curr - jahre) < Math.abs(prev - jahre) ? curr : prev));
        return renditeData[key];
    }

    function updateRenditeSuggestions(jahre) {
      let data = null;
      if (renditeExtremes && renditeExtremes[jahre]) {
        data = renditeExtremes[jahre];
      } else {
        data = getRenditeDataForPeriod(jahre); // Fallback (grob)
      }
      const infoEl = getEl('rendite-info');
      const mid = ((data.min + data.max) / 2).toFixed(1);
      inputs.rendite.value = mid;

      // Farb-Logik: <0 rot, 0–3 gelb, >3 grün (pro Zahl separat)
      const colorClass = (v) => (v < 0 ? 'text-red-400' : (v < 3 ? 'text-yellow-400' : 'text-green-400'));
      const minSpan = `<span class="font-bold ${colorClass(data.min)}">${data.min}%</span>`;
      const maxSpan = `<span class="font-bold ${colorClass(data.max)}">${data.max}%</span>`;

      // Kein Quellhinweis mehr anzeigen
      infoEl.innerHTML = `Historische Spanne p.a.: ${minSpan} bis ${maxSpan}`;
    }

    function createGrowthChartSVG() { return `<svg viewBox="0 0 100 60" class="w-20 h-12 mb-1"><rect x="10" y="40" width="15" height="20" fill="#3b82f6" opacity="0.6"></rect><rect x="30" y="30" width="15" height="30" fill="#3b82f6" opacity="0.8"></rect><rect x="50" y="20" width="15" height="40" fill="#3b82f6"></rect><rect x="70" y="10" width="15" height="50" fill="#6366f1"></rect></svg>`; }
    function calculateOverflow(inflow, current, limit) { if (limit <= 0) return { tagesgeldInflow: inflow, depotOverflow: 0 }; const potential = current + inflow; if (potential <= limit) return { tagesgeldInflow: inflow, depotOverflow: 0 }; const overflow = potential - limit; return { tagesgeldInflow: inflow - overflow, depotOverflow: overflow }; }
    function openModal(modalId) { getEl(modalId).classList.add('modal-active'); }
    function closeModal(modalId) { getEl(modalId).classList.remove('modal-active'); }
    const fixkostenModal = { list: getEl('fixkosten-list'), total: getEl('modal-total') };
    function saveFixkosten() { calculateAndUpdate(); closeModal('fixkosten-modal'); }
    function renderFixkostenList() { fixkostenModal.list.innerHTML = ''; let total = 0; fixkostenItems.forEach((item, index) => { const itemEl = document.createElement('div'); itemEl.className = 'grid grid-cols-12 gap-2 items-center'; itemEl.innerHTML = `<input type="text" value="${item.name}" onchange="updateFixkostenItem(${index}, 'name', this.value)" placeholder="Posten" class="col-span-4 bg-gray-700 p-1 rounded"><input type="number" value="${item.amount}" onchange="updateFixkostenItem(${index}, 'amount', this.value)" placeholder="Betrag" class="col-span-2 bg-gray-700 p-1 rounded"><select onchange="updateFixkostenItem(${index}, 'interval', this.value)" class="col-span-2 bg-gray-700 p-1 rounded">${['monthly','quarterly','annually'].map(i => `<option value="${i}" ${item.interval === i ? 'selected' : ''}>${i==='monthly'?'mtl.':i==='quarterly'?'viertelj.':'jährl.'}</option>`).join('')}</select><select onchange="updateFixkostenItem(${index}, 'target', this.value)" class="col-span-3 bg-gray-700 p-1 rounded"><option value="fixkosten" ${item.target==='fixkosten'?'selected':''}>-> Fixkosten</option><option value="depot" ${item.target==='depot'?'selected':''}>-> Sparplan</option></select><button onclick="removeFixkostenItem(${index})" class="col-span-1 text-red-400 hover:text-red-300 text-xl">&times;</button>`; fixkostenModal.list.appendChild(itemEl); total += getMonthlyAmount(item); }); fixkostenModal.total.textContent = formatCurrency(total); }
function updateFixkostenItem(index, key, value) {
  // Normalize types per field
  if (key === 'amount') {
    value = parseFloat(value);
    if (!Number.isFinite(value)) value = 0;
    if (value < 0) value = 0; // no negative amounts
  }
  // Persist change in model
  if (fixkostenItems[index]) {
    fixkostenItems[index][key] = value;
  }
  // Re-render modal list & totals immediately
  renderFixkostenList();
}
    function addFixkostenItem() { fixkostenItems.push({ name: '', amount: 0, interval: 'monthly', target: 'fixkosten' }); renderFixkostenList(); }
    function removeFixkostenItem(index) { fixkostenItems.splice(index, 1); renderFixkostenList(); }
    const depotModal = { list: getEl('depot-list'), total: getEl('depot-total'), warning: getEl('depot-warning'), saveButton: getEl('depot-save-button') };
    function saveDepot() { if(checkDepotTotal()) { calculateAndUpdate(); closeModal('depot-modal'); } }
    function renderDepotList() { depotModal.list.innerHTML = ''; let total = 0; depotItems.forEach((item, index) => { total += item.allocation; const itemEl = document.createElement('div'); itemEl.className = 'grid grid-cols-12 gap-2 items-center'; itemEl.innerHTML = `<input type="color" value="${item.color}" onchange="updateDepotItem(${index}, 'color', this.value)" class="col-span-1 h-8 bg-gray-700 p-0 rounded"><input type="text" value="${item.name}" onchange="updateDepotItem(${index}, 'name', this.value)" placeholder="Fonds / ETF Name" class="col-span-7 bg-gray-700 p-1 rounded"><div class="relative col-span-3"><input type="number" value="${item.allocation}" onchange="updateDepotItem(${index}, 'allocation', this.value)" class="w-full text-right pr-6 bg-gray-700 p-1 rounded"><span class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400">%</span></div><button onclick="removeDepotItem(${index})" class="col-span-1 text-red-400 hover:text-red-300 text-xl">&times;</button>`; depotModal.list.appendChild(itemEl); }); checkDepotTotal(); }
    function updateDepotItem(index, key, value) { if (key === 'allocation') value = parseInt(value, 10) || 0; depotItems[index][key] = value; renderDepotList(); }
    function addDepotItem() { depotItems.push({ name: '', allocation: 0, color: '#'+Math.floor(Math.random()*16777215).toString(16) }); renderDepotList(); }
    function removeDepotItem(index) { depotItems.splice(index, 1); renderDepotList(); }
    function checkDepotTotal() { const total = depotItems.reduce((sum, i) => sum + i.allocation, 0); depotModal.total.textContent = `${total} %`; if (total === 100) { depotModal.total.className = "text-2xl font-bold text-green-400"; depotModal.warning.textContent = ""; depotModal.saveButton.disabled = false; depotModal.saveButton.classList.remove('opacity-50', 'cursor-not-allowed'); return true; } else { depotModal.total.className = "text-2xl font-bold text-red-400"; depotModal.warning.textContent = "Die Summe der Verteilung muss 100% ergeben."; depotModal.saveButton.disabled = true; depotModal.saveButton.classList.add('opacity-50', 'cursor-not-allowed'); return false; } }

    // --- Helpers: Export current SVG flow and Chart.js chart as images ---
    async function svgToPngDataUrl(svgElement, scale = 2, bg = '#ffffff') {
      const rect = svgElement.getBoundingClientRect();

      // 1) Clone the on-screen SVG so we can preprocess without affecting UI
      const clone = svgElement.cloneNode(true);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      clone.setAttribute('width', rect.width);
      clone.setAttribute('height', rect.height);
      clone.removeAttribute('style');

      // 2) Remove mask for export (avoids black rectangle in rasterization)
      const visuals = clone.querySelector('#flow-visuals');
      if (visuals) visuals.removeAttribute('mask');

      // 3) Inject background rect (theme-aware)
      const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bgRect.setAttribute('x', '0');
      bgRect.setAttribute('y', '0');
      bgRect.setAttribute('width', '100%');
      bgRect.setAttribute('height', '100%');
      bgRect.setAttribute('fill', bg);
      clone.insertBefore(bgRect, clone.firstChild);

      // 4) Inline stroke colors on cloned paths (in case CSS vars don't carry over)
      try {
        const originalPaths = svgElement.querySelectorAll('.flow-path, .flow-path-animation, .flow-erase');
        const clonedPaths   = clone.querySelectorAll('.flow-path, .flow-path-animation, .flow-erase');
        clonedPaths.forEach((node, i) => {
          const src = originalPaths[i];
          if (!src) return;
          const cs = getComputedStyle(src);
          if (cs && cs.stroke && cs.stroke !== 'none') node.setAttribute('stroke', cs.stroke);
        });
      } catch (_) {}

      // 5) Serialize the prepared clone and draw it onto a canvas
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(clone);
      const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(800, Math.floor(rect.width * scale));
      canvas.height = Math.max(600, Math.floor(rect.height * scale));

      const ctx = canvas.getContext('2d');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      await new Promise((resolve, reject) => {
        img.onload = () => {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          URL.revokeObjectURL(url);
          resolve();
        };
        img.onerror = reject;
        img.src = url;
      });

      return canvas.toDataURL('image/png');
    }
    function getFlowSnapshotDataUrl() {
      const svg = document.getElementById('flow-svg');
      if (!svg) return null;
      return svgToPngDataUrl(svg, 2, '#ffffff');
    }
    function getChartImageDataUrl() {
      // existierende Instanz nutzen
      if (prognoseChartInstance && typeof prognoseChartInstance.toBase64Image === 'function') {
        try { return prognoseChartInstance.toBase64Image('image/png', 1.0); } catch (_) {}
      }
      // Fallback: temporären Chart rendern
      try {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1000;
        tempCanvas.height = 420;
        const ctx = tempCanvas.getContext('2d');

        const years = parseInt(inputs.anlagezeitraum.value, 10) || 15;
        const dataRange = (renditeExtremes && renditeExtremes[years]) || getRenditeDataForPeriod(years);
        const initialDepot = parseFloat(inputs.depotCurrent.value) || 0;

        const depotSparplanTotal = fixkostenItems
          .filter(i => i.target === 'depot')
          .reduce((s, it) => s + getMonthlyAmount(it), 0);

        const { depotOverflow } = calculateOverflow(
          parseFloat(inputs.tagesgeldCurrent.value) || 0,
          parseFloat(inputs.tagesgeldLimit.value) || 0
        );
        const monthlyInvestment = depotSparplanTotal + depotOverflow;

        const toSeries = (rate) => calculateCompoundInterest(initialDepot, monthlyInvestment, years, rate / 100);
        const sMin = toSeries(dataRange.min);
        const sAvg = toSeries(((dataRange.min + dataRange.max) / 2));
        const sMax = toSeries(dataRange.max);

        const tmpChart = new Chart(ctx, {
          type: 'line',
          data: { labels: sAvg.labels, datasets: [
            { label: 'Pessimistisch', data: sMin.capitalData, borderColor: '#ef4444', fill: false, tension: 0.1 },
            { label: 'Erwartet',      data: sAvg.capitalData, borderColor: '#3b82f6', fill: false, tension: 0.1 },
            { label: 'Optimistisch',  data: sMax.capitalData, borderColor: '#22c55e', fill: false, tension: 0.1 }
          ]},
          options: { responsive: false, animation: false, plugins: { legend: { display: false } } }
        });
        // Sicherstellen, dass gezeichnet wurde
        tmpChart.update();
        const url = tempCanvas.toDataURL('image/png');
        tmpChart.destroy();
        return url;
      } catch (_) {
        return null;
      }
    }

    // Helper: wait for one or more animation frames (lets layout/theme settle)
    async function waitFrames(n = 1) {
      for (let i = 0; i < n; i++) {
        await new Promise(res => requestAnimationFrame(res));
      }
    }

    async function waitForImages(container, timeout = 2500) {
      const imgs = Array.from(container.querySelectorAll('img'));
      const pending = imgs.filter(img => !img.complete || img.naturalWidth === 0);

      if (pending.length === 0) return;

      await Promise.race([
        Promise.all(pending.map(img => new Promise(res => {
          img.addEventListener('load', res, { once: true });
          img.addEventListener('error', res, { once: true }); // not blocking on error
          // Falls das Bild bereits „complete“ ist, sofort auflösen:
          if (img.complete && img.naturalWidth > 0) res();
        }))),
        new Promise(res => setTimeout(res, timeout))
      ]);
    }

    async function prepareAndPrint() {
        const report = getEl('printable-report');

        // --- Force LIGHT THEME for export/print snapshot ---
        const prevTheme = loadTheme();           // 'dark' | 'light'
        applyTheme('light');                     // switch UI tokens
        saveTheme('light');
        // Re-render flows so computed styles & erase strokes match light mode
        calculateAndUpdate();
        await waitFrames(2);                     // let DOM/layout settle

        const themeNote = 'MLP Hell';

        // 1) Gather current inputs (after potential UI changes)
        const incomeVal = formatCurrency(inputs.income.value);
        const konsumMinVal = formatCurrency(inputs.konsumMin.value);
        const konsumLeftoverVal = formatCurrency(inputs.konsumLeftover.value);
        const tgCurVal = formatCurrency(inputs.tagesgeldCurrent.value);
        const tgLimitVal = formatCurrency(inputs.tagesgeldLimit.value);
        const depotCurVal = formatCurrency(inputs.depotCurrent.value);
        const jahre = parseInt(inputs.anlagezeitraum.value, 10);
        const renditeAnn = parseFloat(inputs.rendite.value).toFixed(1) + ' %';

        // 2) Export visualizations (always white background)
        const flowImg = await svgToPngDataUrl(getEl('flow-svg'), 2, '#ffffff');
        const chartImg = getChartImageDataUrl();

        // 3) Build Fixkosten & Depot tables
        const fixRows = fixkostenItems.map(i => `<tr><td>${i.name}</td><td>${formatCurrency(i.amount)}</td><td>${i.interval}</td><td>${i.target}</td></tr>`).join('');
        const depRows = depotItems.map(i => `<tr><td>${i.name}</td><td>${i.allocation}%</td></tr>`).join('');

        // 4) Compose report HTML (theme-neutral for print)
        let html = `
          <h1>Zusammenfassung: Das intelligente Vermögensmanagement</h1>
          <p class="muted">Variante: <strong>${currentVariant}</strong> • Theme: <strong>${themeNote}</strong> • Datum: ${new Date().toLocaleDateString('de-DE')}</p>

          <h2>Ihre Planung</h2>
          <table class="print-table">
            <tbody>
              <tr><th style="width:40%">Nettoeinkommen</th><td>${incomeVal}</td></tr>
              <tr><th>Konsumkonto Mindestbestand</th><td>${konsumMinVal}</td></tr>
              <tr><th>Geschätzter monatlicher Überschuss</th><td>${konsumLeftoverVal}</td></tr>
              <tr><th>Tagesgeldkonto (aktuell)</th><td>${tgCurVal}</td></tr>
              <tr><th>Tagesgeldkonto (Sparziel)</th><td>${tgLimitVal}</td></tr>
              <tr><th>Depotstand (aktuell)</th><td>${depotCurVal}</td></tr>
              <tr><th>Anlagezeitraum</th><td>${jahre} Jahre</td></tr>
              <tr><th>Rendite-Annahme</th><td>${renditeAnn}</td></tr>
            </tbody>
          </table>

          <h2>Fixkosten &amp; Sparpläne</h2>
          <table class="print-table"><thead><tr><th>Posten</th><th>Betrag</th><th>Intervall</th><th>Ziel</th></tr></thead><tbody>${fixRows}</tbody></table>

          <h2>Depot-Aufteilung</h2>
          <table class="print-table"><thead><tr><th>Fonds/ETF</th><th>Verteilung</th></tr></thead><tbody>${depRows}</tbody></table>
        `;
        html += ``; // (Überschrift wird unten im <section> gesetzt)
        report.innerHTML = html;

        // Eigene Seite vorbereiten
        const section = document.createElement('section');
        section.className = 'print-finanzfluss';
        // Fallbacks für Browser, die die CSS-Regel ignorieren
        section.style.breakBefore = 'page';
        section.style.pageBreakBefore = 'always';
        section.innerHTML = `<h2>Dein Finanzfluss (aktueller Stand)</h2>`;

        // Live-DOM klonen: Ströme + Konten + Werte
        const live = getEl('flow-container');
        if (live) {
          const clone = live.cloneNode(true);
          clone.id = 'flow-container-print';

          // Interaktivität entfernen (keine Modals im Print)
          clone.querySelectorAll('[onclick]').forEach(n => n.removeAttribute('onclick'));

          // Deterministische Größe wie im Live-UI
          const cs = getComputedStyle(live);
          clone.style.position = 'relative';
          clone.style.minHeight = cs.minHeight || '1150px';
          clone.style.height    = cs.height || '1150px';
          clone.style.width     = '100%';

          const holder = document.createElement('div');
          holder.style.marginTop = '8px';
          holder.appendChild(clone);
          section.appendChild(holder);
        }

        // Abschnitt (eigene Seite) anhängen
        report.appendChild(section);

        // NEU: sicherstellen, dass die <img>-Tags wirklich fertig sind
        await waitForImages(report, 2500);
        await waitFrames(1); // ein Frame für Layout

        // 5) Print
        const restoreTheme = () => {
          applyTheme(prevTheme || 'dark');
          saveTheme(prevTheme || 'dark');
          calculateAndUpdate();
        };
        const onAfterPrint = () => { window.removeEventListener('afterprint', onAfterPrint); restoreTheme(); };
        window.addEventListener('afterprint', onAfterPrint);
        window.print();
    }
    
    // --- THEME HANDLING (Dark/MLP Light) ---
    function applyTheme(theme) {
        const root = document.getElementById('theme-root');
        if (!root) return;
        root.classList.remove('theme-dark','theme-light');
        root.classList.add(theme === 'light' ? 'theme-light' : 'theme-dark');

        // Flow gradient colors adapt to theme
        const grad = document.querySelector('#flow-gradient');
        if (grad) {
            const stops = grad.querySelectorAll('stop');
            if (stops.length >= 2) {
                if (theme === 'light') {
                    // Pure MLP blue stream
                    stops[0].setAttribute('style', 'stop-color: var(--mlp-blue-1);');
                    stops[1].setAttribute('style', 'stop-color: var(--mlp-blue-1);');
                } else {
                    // force classic dark gradient
                    stops[0].setAttribute('style', 'stop-color: #3b82f6;');
                    stops[1].setAttribute('style', 'stop-color: #6366f1;');
                }
            }
        }
    }
    function loadTheme() {
        try { return localStorage.getItem('vd_theme') || 'dark'; } catch(_) { return 'dark'; }
    }
    function saveTheme(theme) {
        try { localStorage.setItem('vd_theme', theme); } catch(_) {}
    }

    // INITIALIZATION
    document.addEventListener('DOMContentLoaded', () => {
        inputs = { income: getEl('income'), konsumMin: getEl('konsumMin'), konsumLeftover: getEl('konsumLeftover'), tagesgeldCurrent: getEl('tagesgeldCurrent'), tagesgeldLimit: getEl('tagesgeldLimit'), depotCurrent: getEl('depotCurrent'), anlagezeitraum: getEl('anlagezeitraum'), rendite: getEl('rendite') };
        basins = { gehalt: getEl('gehalt-basin'), fixkosten: getEl('fixkosten-basin'), konsum: getEl('konsum-basin'), tagesgeld: getEl('tagesgeld-basin'), depot: getEl('depot-basin') };
        flowContainer = getEl('flow-container');

        // THEME init
        const themeSwitch = getEl('theme-switch');
        const initialTheme = loadTheme(); // 'dark' | 'light'
        applyTheme(initialTheme);
        if (themeSwitch) {
            // checked == Dark (rechts), unchecked == MLP Light (links)
            themeSwitch.checked = (initialTheme === 'dark');
            themeSwitch.addEventListener('change', (e) => {
                const t = e.target.checked ? 'dark' : 'light';
                applyTheme(t);
                saveTheme(t);
                // Nach Themewechsel neu zeichnen
                calculateAndUpdate();
            });
        }

        const anlagezeitraumLabel = getEl('anlagezeitraum-label');
        const variantSwitch = getEl('variant-switch');
        const varianteALabel = getEl('variante-a-label');
        const varianteBLabel = getEl('variante-b-label');
        const variantInfo = getEl('variant-info');

        function setVariantUI() {
            if (currentVariant === 'A') {
                varianteALabel.classList.add('text-white', 'font-semibold');
                varianteALabel.classList.remove('text-gray-500');
                varianteBLabel.classList.add('text-gray-500');
                varianteBLabel.classList.remove('text-white', 'font-semibold');
                variantInfo.textContent = 'Variante A: Gehalt geht auf das Fixkostenkonto.';
            } else {
                varianteBLabel.classList.add('text-white', 'font-semibold');
                varianteBLabel.classList.remove('text-gray-500');
                varianteALabel.classList.add('text-gray-500');
                varianteALabel.classList.remove('text-white', 'font-semibold');
                variantInfo.textContent = 'Variante B: Gehalt geht auf das Konsumkonto.';
            }
            // Keep consultation view consistent when variant changes
            applyConsultationVisibility();
            calculateAndUpdate();
        }

        variantSwitch.addEventListener('change', (e) => {
            currentVariant = e.target.checked ? 'B' : 'A';
            setVariantUI();
        });

        inputs.anlagezeitraum.addEventListener('input', (e) => {
            const jahre = parseInt(e.target.value, 10);
            anlagezeitraumLabel.textContent = `${jahre} Jahre`;
            updateRenditeSuggestions(jahre);
        });
        
        const observer = new ResizeObserver(() => calculateAndUpdate());
        observer.observe(flowContainer);
        
        setTimeout(() => {
            renderFixkostenList();
            renderDepotList();
            setVariantUI();
            updateRenditeSuggestions(parseInt(inputs.anlagezeitraum.value, 10));
            calculateAndUpdate();

            // Load fine-grained min/max ranges from TXT (MLP-Dreieck)
            loadRenditeExtremes();

            // Keep info live while sliding
            inputs.anlagezeitraum.addEventListener('input', () => {
                const jahre = parseInt(inputs.anlagezeitraum.value, 10);
                const label = getEl('anlagezeitraum-label');
                if (label) label.textContent = `${jahre} Jahre`;
                updateRenditeSuggestions(jahre);
            });

            // Beratungsansicht Buttons
            const consultToggle = getEl('consult-toggle-btn');
            const consultNext   = getEl('consult-next-btn');
            if (consultToggle) consultToggle.addEventListener('click', () => setConsultationMode(!consultationMode));
            if (consultNext)   consultNext.addEventListener('click', () => nextConsultationStep());
        }, 100);
    });
    </script>
    <script src="scripts/a11y.js" defer></script>
    <script src="scripts/autoRecalc.js" defer></script>
    <script src="scripts/variantFix.js" defer></script>
    <script src="scripts/reloadButton.js" defer></script>
    <script src="scripts/recalcFab.js" defer></script>
    <script src="scripts/removeHeaderIcon.js" defer></script>
</body>
</html>


