<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Das strategische Vermögensmanagement</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .account-basin {
            background-color: #1f2937; border: 1px solid #374151; padding: 1rem; border-radius: 0.75rem;
            text-align: center; width: 220px; height: 140px; display: flex; flex-direction: column;
            justify-content: center; align-items: center; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transition: all 0.3s ease-in-out; position: absolute; z-index: 10; overflow: hidden;
        }
        .flow-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; overflow: visible; }
        .flow-path { fill: none; stroke: var(--mlp-blue-1); stroke: url(#flow-gradient); stroke-linecap: round; stroke-linejoin: round; transition: opacity 0.5s, stroke-width 0.5s; opacity: 0; }
        .flow-path.active { opacity: 1; }
        .flow-path-animation { stroke: white; stroke-width: 1.5px; stroke-dasharray: 10 15; animation: flow 2s linear infinite; opacity: 0; transition: opacity 0.5s; }
        .flow-path.active + .flow-path-animation { opacity: 0.4; }
        /* Erase any underlay with background color (covers legacy grey ribbons) */
        .flow-erase {
          fill: none;
          stroke-linecap: round;
          stroke-linejoin: round;
          opacity: 1;
          pointer-events: none;
          shape-rendering: geometricPrecision;
        }
        .theme-light .flow-erase { stroke: #ffffff !important; }
        .theme-dark  .flow-erase { stroke: #111827 !important; }
        /* Light theme: full blue flows, no grey halo */
        .theme-light .flow-path { stroke: var(--mlp-blue-1) !important; filter: none; }
        .theme-light .flow-path-animation { stroke: #2f6fb2; stroke-dasharray: 8 14; opacity: .9; }
        .flow-dot { fill: #60a5fa; opacity: .95; }
        .theme-light .flow-dot { fill: var(--mlp-blue-2); }
        @keyframes flow { from { stroke-dashoffset: 0; } to { stroke-dashoffset: -25; } }
        .flow-label { position: absolute; color: #9ca3af; font-size: 0.75rem; font-weight: 500; z-index: 15; transform: translate(-50%, -130%); white-space: nowrap; transition: top 0.3s, left 0.3s; }
        /* Better readability for labels on blue rivers (light) */
        .theme-light .flow-label {
          color: var(--fg);
          background: rgba(255,255,255,.95);
          border: 1px solid var(--border);
          padding: 2px 6px;
          border-radius: 999px;
          line-height: 1.1;
          box-shadow: 0 1px 2px rgba(0,0,0,.06);
        }
        .flow-value { position: absolute; background-color: #111827; color: #d1d5db; padding: 4px 10px; border-radius: 9999px; font-size: 0.9rem; font-weight: 600; z-index: 15; border: 1px solid #4b5563; white-space: nowrap; transform: translate(-50%, -50%); transition: top 0.3s, left 0.3s; }
        .limit-line { position: absolute; width: 100%; height: 2px; left: 0; z-index: 12; }
        .limit-line span { position: absolute; right: 4px; transform: translateY(-50%); font-size: 10px; background: #1f2937; padding: 0 3px; font-weight: 500;}
        .modal { display: none; }
        .modal-active { display: flex; }
        .schutzschirm {
            fill: rgba(59, 130, 246, 0.15);
            stroke: rgba(96, 165, 250, 0.4);
            stroke-width: 2px;
            transition: opacity 0.5s;
            animation: pulse-shield 4s infinite ease-in-out;
            pointer-events: none;
        }
        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #374151; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(26px); }
        
        #printable-report { display: none; }
        @media print { body > *:not(#printable-report) { display: none !important; } #printable-report { display: block; color: #000; background: #fff; } .print-table { width: 100%; border-collapse: collapse; margin-top: 1rem; margin-bottom: 2rem; } .print-table th, .print-table td { border: 1px solid #ccc; padding: 8px; text-align: left; } .print-table th { background-color: #f2f2f2; } .print-break { page-break-after: always; break-after: page; height: 1px; } }
        @media print {
          /* Eigene Seite für den Finanzfluss */
          .print-finanzfluss {
            break-before: page;        /* modern */
            page-break-before: always; /* legacy */
          }
          /* Verhindert „hängende“ Überschrift am Seitenende */
          .print-finanzfluss h2 {
            break-after: avoid;
            page-break-after: avoid;
          }
        }

        /* === THEME TOKENS (Dark stays default) === */
        :root {
          --mlp-blue: #002F6C;
          --mlp-blue-1: #002F6C;  /* deep navy */
          --mlp-blue-2: #3C6AA3;  /* lighter MLP blue for shading */
          --mlp-gold: #BDA177;
          --input-bg: #1f2937;
          --input-border: #374151;
        }
        .theme-dark {
          --bg: #111827;        /* body bg */
          --fg: #FFFFFF;        /* text color */
          --card: #1f2937;      /* panels */
          --border: #374151;    /* borders */
          --muted: #9ca3af;     /* secondary text */
          --accent1: #3b82f6;   /* gradient start */
          --accent2: #6366f1;   /* gradient end */
          --input-bg: rgba(17, 24, 39, 0.92);
          --input-border: #374151;
        }
        .theme-light {
          --bg: #FFFFFF;
          --fg: #111827;
          --card: #F9FAFB;
          --border: #E5E7EB;
          --muted: #6B7280;
          --accent1: var(--mlp-blue);  /* MLP Blau */
          --accent2: var(--mlp-gold);  /* MLP Gold */
          --input-bg: #ffffff;
          --input-border: #d0d7e3;
        }

        /* Base background/text via CSS vars (keine Änderung an Tailwind nötig) */
        body { background: var(--bg); color: var(--fg); }

        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border: 0;
        }

        /* Planning cockpit */
        .planning-panel{position:relative;background:var(--card);border-radius:24px;border:1px solid var(--border);padding:clamp(2.4rem,3vw+2rem,3.5rem) clamp(1.6rem,2vw+1.2rem,2.6rem);display:flex;flex-direction:column;gap:1.75rem;box-shadow:0 24px 48px -28px rgba(0,47,108,0.45);}
        .theme-dark .planning-panel{background:linear-gradient(150deg,#1e293b 0%,#0f172a 100%);border-color:rgba(148,163,184,0.15);box-shadow:0 35px 55px -35px rgba(15,23,42,0.8);}
        .panel-header{display:flex;flex-direction:column;gap:1.5rem;align-items:flex-start;}
        @media (min-width:768px){.panel-header{flex-direction:row;justify-content:space-between;align-items:flex-end;gap:2rem;}}
        .panel-title{max-width:420px;display:flex;flex-direction:column;gap:.4rem;align-items:flex-start;text-align:left;padding-left:1.5rem;}
        .panel-eyebrow{font-size:.7rem;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);font-weight:700;}
        .panel-title h2{margin:0;font-size:clamp(1.9rem,2vw+1.6rem,2.4rem);font-weight:700;color:var(--fg);}
        .panel-controls{display:flex;align-items:center;gap:.65rem;flex-wrap:wrap;justify-content:flex-end;}
        .control-chip{position:relative;display:inline-flex;align-items:center;justify-content:center;width:44px;height:44px;border:1px solid var(--border);border-radius:14px;background:rgba(0,47,108,0.04);transition:all .25s ease;cursor:pointer;}
        .panel-controls .control-chip:hover{border-color:var(--accent1);color:var(--accent1);}
        .control-chip:focus-within{box-shadow:0 0 0 3px rgba(0,47,108,0.18);}
        .theme-dark .control-chip{background:rgba(148,163,184,0.08);border-color:rgba(148,163,184,0.2);}
        .control-chip input{position:absolute;inset:0;opacity:0;cursor:pointer;}
        .chip-icon,.chip-pair{display:flex;align-items:center;justify-content:center;width:100%;height:100%;border-radius:inherit;background:transparent;gap:.2rem;transition:background .25s ease,color .25s ease;}
        .control-chip .icon{width:18px;height:18px;color:var(--muted);transition:opacity .2s ease,transform .2s ease;}
        .control-chip--toggle .icon-moon{opacity:0;transform:scale(.65);}
        .control-chip--toggle input:checked + .chip-icon{background:rgba(0,47,108,0.08);}
        .theme-light .control-chip--toggle input:checked + .chip-icon{background:rgba(0,47,108,0.12);}
        .control-chip--toggle input:checked + .chip-icon .icon-sun{opacity:0;transform:scale(.65);}
        .control-chip--toggle input:checked + .chip-icon .icon-moon{opacity:1;transform:scale(1);}
        .control-chip--toggle input:checked + .chip-icon .icon{color:var(--accent1);}
        .chip-pair{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.2rem;align-items:center;justify-items:center;}
        .chip-state{display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:999px;font-size:.8rem;font-weight:600;color:var(--muted);background:rgba(0,47,108,0.05);transition:all .2s ease;}
        .theme-dark .chip-state{background:rgba(148,163,184,0.12);color:#cbd5f5;}
        .chip-state--active{color:#ffffff;background:linear-gradient(135deg,var(--accent1),var(--accent2));box-shadow:0 10px 18px -12px rgba(0,47,108,0.6);}
        .control-chip--consultation{width:44px;}
        .control-chip--consultation .chip-button{display:flex;align-items:center;justify-content:center;width:100%;height:100%;border:none;background:transparent;color:var(--muted);cursor:pointer;transition:color .2s ease,background .2s ease;}
        .control-chip--consultation .chip-button:hover{color:var(--accent1);}
        .control-chip--consultation .chip-button .icon{width:20px;height:20px;}
        .control-chip--consultation .chip-button.hidden{display:none;}
        .control-chip--consultation.is-active{background:linear-gradient(135deg,var(--accent1),var(--accent2));border-color:transparent;box-shadow:0 10px 18px -12px rgba(0,47,108,0.6);}
        .control-chip--consultation.is-active .chip-button .icon{color:#ffffff;}
        .btn{display:inline-flex;align-items:center;justify-content:center;gap:.35rem;border-radius:999px;font-weight:600;transition:all .25s ease;cursor:pointer;border:none;}
        .btn-sm{font-size:.85rem;padding:.45rem .95rem;}
        .btn-lg{font-size:.95rem;padding:.75rem 1.4rem;}
        .btn-block{width:100%;}
        .btn-primary{background:linear-gradient(135deg,var(--accent1),var(--accent2));color:#fff;}
        .btn-primary:hover{filter:brightness(1.05);box-shadow:0 18px 32px -18px rgba(0,47,108,0.65);}
        .btn-secondary{background:transparent;border:1px solid var(--border);color:var(--fg);}
        .btn-secondary:hover{border-color:var(--accent1);color:var(--accent1);box-shadow:0 0 0 3px rgba(0,47,108,0.12);}
        .btn-ghost{background:transparent;color:var(--muted);}
        .btn-ghost:hover{color:var(--accent1);}
        .panel-note{display:flex;align-items:flex-start;gap:.75rem;font-size:.85rem;color:var(--muted);background:rgba(0,47,108,0.05);border-radius:14px;padding:.9rem 1.1rem;border:1px solid rgba(0,47,108,0.1);}
        .panel-note::before{content:'i';display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;border-radius:50%;background:rgba(0,47,108,0.12);color:var(--accent1);font-weight:700;flex-shrink:0;}
        .theme-dark .panel-note{background:rgba(148,163,184,0.08);border-color:rgba(148,163,184,0.16);color:#e2e8f0;}
        .theme-dark .panel-note::before{background:rgba(99,102,241,0.2);color:var(--accent2);}
        .panel-body{display:flex;flex-direction:column;gap:1.25rem;}
        .panel-section{display:flex;flex-direction:column;gap:1rem;padding:1.25rem 1.35rem 1.5rem;border-radius:18px;border:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,0.7)0%,rgba(244,247,252,0.85)100%);}
        .theme-dark .panel-section{background:rgba(15,23,42,0.55);border-color:rgba(148,163,184,0.12);}
        .panel-section[data-tone="blue"] .section-heading h3{color:var(--accent1);}
        .panel-section[data-tone="gold"] .section-heading h3{color:var(--mlp-gold);}
        .panel-section[data-tone="teal"] .section-heading h3{color:#3aa8a2;}
        .panel-section[data-tone="slate"] .section-heading h3{color:#4c65a8;}
        .section-heading{display:flex;flex-direction:column;gap:.35rem;}
        .section-heading h3{margin:0;font-size:1.2rem;font-weight:700;color:var(--fg);}
        .section-heading .section-subtitle{font-size:.75rem;font-weight:600;color:var(--muted);letter-spacing:.08em;text-transform:uppercase;}
        .section-eyebrow{font-size:.7rem;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);font-weight:700;}
        .section-grid{display:grid;gap:1rem;}
        .section-grid--two{grid-template-columns:repeat(auto-fit,minmax(160px,1fr));}
        .section-stack{display:flex;flex-direction:column;gap:1rem;}
        .mlp-input{display:flex;flex-direction:column;gap:.55rem;}
        .mlp-input label{font-size:.85rem;font-weight:600;color:var(--muted);}
        .mlp-range-group{gap:0.4rem;}
        .range-meta{display:flex;justify-content:space-between;align-items:center;font-size:0.75rem;color:var(--muted);margin-bottom:0.25rem;}
        .range-value{font-weight:600;color:var(--accent1);}
        .input-frame{display:flex;align-items:center;gap:.6rem;background:var(--input-bg);border:1px solid var(--input-border);border-radius:12px;padding:0 1rem;height:48px;transition:border-color .25s ease,box-shadow .25s ease;}
        .mlp-input-field{flex:1;border:none;background:transparent;color:var(--fg);font-size:1rem;font-weight:600;outline:none;}
        .mlp-input-field::-webkit-outer-spin-button,.mlp-input-field::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}
        .mlp-input-field[type=number]{-moz-appearance:textfield;}
        .input-prefix,.input-suffix{font-size:.9rem;font-weight:600;color:var(--muted);}
        .input-frame:focus-within{border-color:var(--accent1);box-shadow:0 0 0 3px rgba(0,47,108,0.18);}
        .theme-dark .input-frame{background:rgba(15,23,42,0.9);border-color:rgba(148,163,184,0.18);}
        .theme-dark .input-frame:focus-within{border-color:var(--accent1);box-shadow:0 0 0 3px rgba(63,103,190,0.35);}
        .theme-dark .input-prefix,.theme-dark .input-suffix{color:#cbd5f5;}
        .label-highlight{color:var(--accent1);font-weight:700;}
        .mlp-range{width:100%;height:6px;border-radius:999px;background:linear-gradient(90deg,rgba(0,47,108,0.15),rgba(189,161,119,0.15));outline:none;-webkit-appearance:none;appearance:none;}
        .mlp-range::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:linear-gradient(135deg,var(--accent1),var(--accent2));border:none;box-shadow:0 8px 18px rgba(0,47,108,0.25);cursor:pointer;}
        .mlp-range::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:linear-gradient(135deg,var(--accent1),var(--accent2));border:none;box-shadow:0 8px 18px rgba(0,47,108,0.25);cursor:pointer;}
        .mlp-range::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:linear-gradient(90deg,var(--accent1),var(--accent2));}
        .mlp-range::-moz-range-track{height:6px;border-radius:999px;background:linear-gradient(90deg,var(--accent1),var(--accent2));}
        .section-note{font-size:.8rem;color:var(--muted);background:rgba(0,47,108,0.05);padding:.75rem 1rem;border-radius:12px;text-align:center;}
        .theme-dark .section-note{background:rgba(148,163,184,0.12);color:#e2e8f0;}
        .booking-type-group{display:flex;flex-wrap:wrap;gap:.55rem;justify-content:center;}
        .booking-toolbar{display:flex;flex-wrap:wrap;gap:.75rem;align-items:center;font-size:.8rem;color:var(--muted);}
        .booking-toolbar label{font-weight:600;color:var(--muted);}
        .select-field{width:100%;background:var(--input-bg);border:1px solid var(--input-border);border-radius:12px;padding:.6rem .9rem;color:var(--fg);font-size:.9rem;transition:border-color .25s ease,box-shadow .25s ease;outline:none;}
        .select-field:focus{border-color:var(--accent1);box-shadow:0 0 0 3px rgba(0,47,108,0.18);}
        .theme-dark .select-field{background:rgba(15,23,42,0.9);border-color:rgba(148,163,184,0.18);color:#f1f5f9;}
        .link-danger{color:#ef4444;font-weight:600;}
        .link-danger:hover{color:#dc2626;}
        .print-area{margin-top:.5rem;}
        .print-area .print-btn{display:inline-flex;align-items:center;justify-content:center;gap:.75rem;border-radius:16px;padding:.9rem 1.2rem;}
        .print-area .print-btn svg{width:20px;height:20px;}
        /* Panels/Borders auf Theme heben */
        .theme-light .bg-gray-800 { background-color: var(--card) !important; }
        .theme-light .bg-gray-900 { background-color: var(--bg) !important; }
        .theme-light .border-gray-700 { border-color: var(--border) !important; }
        .theme-light .text-white { color: var(--fg) !important; }
        .theme-light .text-gray-400 { color: var(--muted) !important; }

        /* Flow labels/pills harmonisieren */
        .flow-label { color: var(--muted); }
        .flow-value { background-color: #111827; color: #d1d5db; border-color: #4b5563; }
        .theme-light .flow-value { background-color: rgba(255,255,255,0.85); border-color: var(--border); color: var(--fg); }

        /* Mini Theme Toggle (Header) */
        /* -------- Light Theme Polish & Overrides -------- */
        /* Inputs & selects */
        .theme-light input[type="number"],
        .theme-light input[type="text"],
        .theme-light input[type="range"],
        .theme-light select,
        .theme-light textarea {
          background: #ffffff !important;
          color: #111827 !important;
          border-color: var(--border) !important;
        }
        .theme-light .bg-gray-700 { background-color: #ffffff !important; }
        .theme-light .text-gray-300 { color: #374151 !important; }
        .theme-light .bg-gray-700 .text-gray-400,
        .theme-light .text-gray-400 { color: var(--muted) !important; }

        /* Panels / cards / modals */
        .theme-light .account-basin {
          background-color: var(--card) !important;
          border-color: var(--border) !important;
          box-shadow: 0 8px 18px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.05) !important;
        }
        .theme-light .modal .bg-gray-800 { background-color: #ffffff !important; }
        .theme-light .modal .bg-gray-900 { background-color: #ffffff !important; }
        .theme-light .border-gray-600 { border-color: var(--border) !important; }

        /* Badges / helper boxes */
        .theme-light .limit-line span { background: #ffffff !important; color: #111827 !important; }

        /* Flow animation color on light */
        .theme-light .flow-path-animation { stroke: var(--mlp-blue-1); opacity: .5; }

        /* Mask strokes (define visible river area) */
        .flow-mask-stroke {
          fill: none;
          stroke: #ffffff;
          stroke-linecap: round;
          stroke-linejoin: round;
          pointer-events: none;
          shape-rendering: geometricPrecision;
        }

        /* Ensure text colors in headings/labels are dark enough */
        .theme-light h1, .theme-light h2, .theme-light h3, .theme-light label, .theme-light p { color: #111827; }
        .theme-light .text-blue-400, .theme-light .text-green-400, .theme-light .text-red-400, .theme-light .text-yellow-300 { filter: saturate(.95); }

        /* ===== UI Polish ===== */
        /* Smooth theme transitions */
        body, .account-basin, input, select, textarea, .flow-value, .flow-label {
          transition: background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
        }

        /* Light header text overrides (keeps markup unchanged) */
        .theme-light h1.text-white { color: var(--fg) !important; }
        .theme-light p.text-gray-400 { color: var(--muted) !important; }

        /* Inputs focus ring tuned to MLP blue */
        .theme-light input:focus, .theme-light select:focus, .theme-light textarea:focus {
          outline: none;
          border-color: var(--mlp-blue) !important;
          box-shadow: 0 0 0 3px rgba(0,47,108,.15);
        }

        /* Primary action hover gentle for light */
        .theme-light .bg-purple-600:hover { filter: brightness(1.05); }

        /* Print button styling */
        .print-btn {
          transition: all .25s ease;
          border: 1px solid var(--border);
          background: transparent;
          color: var(--fg);
        }
        .print-btn:hover {
          border-color: var(--accent1);
          color: var(--accent1);
        }
        .theme-dark .print-btn {
          background: rgba(148, 163, 184, 0.08);
          border-color: rgba(148, 163, 184, 0.2);
          color: #f1f5f9;
        }
        .theme-light .print-btn {
          background: linear-gradient(135deg, rgba(0, 47, 108, 0.9), rgba(189, 161, 119, 0.9));
          border-color: transparent;
          color: #ffffff;
        }
        .theme-light .print-btn:hover {
          filter: brightness(1.05);
        }

        /* Cards subtle separation in light */
        .theme-light .bg-gray-800 {
          box-shadow: 0 10px 24px rgba(0,0,0,.06), 0 2px 8px rgba(0,0,0,.04) !important;
        }

        /* Section dividers lighter in light */
        .theme-light hr.border-gray-700 { border-color: #e5e7eb !important; }

        /* Flow pill font weight slightly lower in light */
        .theme-light .flow-value { font-weight: 500; }
        .theme-light .flow-value {
          box-shadow: 0 1px 2px rgba(0,0,0,.06);
        }

        /* --- Ensure body flips to light despite Tailwind classes --- */
        .theme-light.bg-gray-900 { background-color: var(--bg) !important; }
        .theme-light.text-white  { color: var(--fg) !important; }

        /* --- Extra MLP accents in Light --- */
        /* Primary action becomes MLP blue in light */
        .theme-light .bg-purple-600 { background-color: var(--mlp-blue) !important; }
        .theme-light .hover\:bg-purple-700:hover { background-color: #003a84 !important; }

        /* Headings and section titles in MLP blue, yellow accents in MLP gold */
        .theme-light h1, .theme-light h2, .theme-light h3,
        .theme-light .section-title { color: var(--mlp-blue) !important; }
        .theme-light .text-yellow-300 { color: var(--mlp-gold) !important; }

        /* Light theme info badges and pills with MLP tint */
        .theme-light .flow-value { border-color: #d5e0ee !important; }

        /* Inputs range track for light in subtle grey with MLP thumb */
        .theme-light input[type="range"] { background: #e5e7eb !important; }
        .theme-light input[type="range"]::-webkit-slider-thumb { background: var(--mlp-blue); }
        .theme-light input[type="range"]::-moz-range-thumb { background: var(--mlp-blue); }
        #rendite-info .text-xs { font-size: 0.7rem; }
    /* --- Print helpers for embedded images --- */
    #printable-report img { max-width: 100%; height: auto; display: block; margin: 10px auto; }
    #printable-report h1, #printable-report h2, #printable-report h3 { color: #000 !important; }
    #printable-report .muted { color: #333 !important; font-size: 12px; }
        .booking-type-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 16px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            background-color: rgba(59, 130, 246, 0.15);
            color: #dbeafe;
            outline: none;
        }
        .booking-type-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 18px -10px rgba(15, 23, 42, 0.35);
        }
        .booking-type-btn svg {
            width: 22px;
            height: 22px;
            pointer-events: none;
        }
        .booking-type-btn:focus-visible {
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.6);
        }
        .booking-type-btn-active {
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.35);
            border-color: rgba(96, 165, 250, 0.65) !important;
            transform: translateY(-1px);
        }
        .booking-calendar {
            display: grid;
            grid-template-columns: repeat(7, minmax(0, 1fr));
            gap: 0.5rem;
        }
        .booking-day {
            position: relative;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            padding: 0.35rem 0.3rem 0.5rem;
            min-height: 64px;
            background-color: rgba(17, 24, 39, 0.6);
            cursor: pointer;
            transition: border-color 0.2s ease, transform 0.15s ease;
        }
        .booking-day:hover {
            transform: translateY(-1px);
            border-color: rgba(96, 165, 250, 0.7);
        }
        .booking-day.has-booking {
            border-color: rgba(96, 165, 250, 0.8);
            background-color: rgba(37, 99, 235, 0.12);
        }
        .booking-day--overflow{background-color:rgba(189,161,119,0.12);border-color:rgba(189,161,119,0.45);} .booking-day--overflow .booking-day-number{color:var(--accent1);}
        .booking-day-number {
            font-size: 0.75rem;
            font-weight: 600;
            color: #9ca3af;
        }
        .booking-day-content {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.35rem;
        }
        .booking-entry-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 9999px;
            border: 1px solid transparent;
            background-color: rgba(255, 255, 255, 0.04);
            color: #d1d5db;
            transition: transform 0.15s ease, border-color 0.2s ease, color 0.2s ease;
        }
        .booking-entry-btn svg {
            width: 0.9rem;
            height: 0.9rem;
        }
        .booking-entry-btn:hover {
            transform: scale(1.05);
            border-color: rgba(239, 68, 68, 0.6);
            color: #fca5a5;
        }
        .booking-calendar .booking-day-header {
            cursor: default;
            background: transparent;
            border: none;
            min-height: auto;
            padding: 0;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #9ca3af;
        }
        .booking-day-empty {
            pointer-events: none;
            cursor: default;
            border: none;
            background: transparent;
            min-height: 0;
            padding: 0;
        }
        .booking-hint-strong {
            color: #bfdbfe;
        }
        .theme-light .booking-type-btn {
            background-color: rgba(15, 47, 85, 0.08);
            color: #0f2f55;
            border-color: rgba(15, 47, 85, 0.12);
        }
        .theme-light .booking-day {
            background-color: rgba(249, 250, 251, 0.9);
            border-color: #d1d5db;
        }
        .theme-light .booking-day:hover {
            border-color: rgba(15, 47, 85, 0.55);
        }
        .theme-light .booking-day.has-booking {
            background-color: rgba(214, 226, 247, 0.9);
        }
        .theme-light .booking-day--overflow{background-color:rgba(240,233,222,0.9);border-color:rgba(189,161,119,0.45);} .theme-light .booking-day--overflow .booking-day-number{color:#7b5a30;}
        .theme-light .booking-day-number {
            color: #4b5563;
        }
        .theme-light .booking-entry-btn {
            background-color: rgba(15, 47, 85, 0.05);
            color: #0f2f55;
        }
        .theme-light .booking-entry-btn:hover {
            border-color: rgba(193, 50, 74, 0.6);
            color: #c1324a;
        }
        .print-booking-entry {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .print-booking-entry svg {
            width: 16px;
            height: 16px;
        }
        .print-booking-icon {
            display: inline-flex;
            align-items: center;
        }
        .print-booking-entry + .print-booking-entry {
            margin-top: 4px;
        }
        #printable-report .print-table-bookings td {
            vertical-align: top;
        }
    </style>
</head>
<body class="theme-dark bg-gray-900 text-white p-4 lg:p-8 overflow-x-hidden" id="theme-root">

    <div id="main-content" class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-12">
            <h1 class="text-3xl md:text-5xl font-bold text-white mb-2">Das strategische Vermögensmanagement</h1>
            <p class="text-md md:text-lg text-gray-400">Plane deine Finanzen vom Gehalt bis zum Investment.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Input Controls -->
            <aside class="w-full lg:w-1/3 xl:max-w-lg">
                <div class="planning-panel" aria-labelledby="planning-title">
                    <header class="panel-header">
                        <div class="panel-title">
                            <span class="panel-eyebrow">Planungs-Cockpit</span>
                            <h2 id="planning-title" class="sr-only">Deine Planung</h2>
                        </div>
                        <div class="panel-controls" role="group" aria-label="Schnellaktionen">
                            <label class="control-chip control-chip--toggle" title="Darstellung wechseln">
                                <input type="checkbox" id="theme-switch" aria-label="Theme umschalten (Hell/Dunkel)" />
                                <span class="chip-icon" aria-hidden="true">
                                    <svg class="icon icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="4" />
                                        <path d="M12 2v2" />
                                        <path d="M12 20v2" />
                                        <path d="M4.93 4.93l1.42 1.42" />
                                        <path d="M17.65 17.65l1.42 1.42" />
                                        <path d="M2 12h2" />
                                        <path d="M20 12h2" />
                                        <path d="M4.93 19.07l1.42-1.42" />
                                        <path d="M17.65 6.35l1.42-1.42" />
                                    </svg>
                                    <svg class="icon icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 12.79A9 9 0 0 1 11.21 3 7 7 0 1 0 21 12.79z" />
                                    </svg>
                                </span>
                            </label>
                            <label class="control-chip control-chip--variant" title="Variante A/B umschalten">
                                <input type="checkbox" id="variant-switch" aria-label="Variante A/B umschalten">
                                <span class="chip-pair" aria-hidden="true">
                                    <span id="variante-a-label" class="chip-state chip-state--active">A</span>
                                    <span id="variante-b-label" class="chip-state">B</span>
                                </span>
                            </label>
                            <div class="control-chip control-chip--consultation" title="Beratung">
                                <button id="consult-toggle-btn" class="chip-button" type="button" aria-label="Beratung starten">
                                    <svg class="icon icon-mlp" viewBox="0 0 24 24" aria-hidden="true">
                                        <circle cx="10" cy="12" r="5.5" stroke="currentColor" stroke-width="1.6" fill="none" />
                                        <path d="M10 8.5v7" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" />
                                        <path d="M18 7h3v10h-3z" fill="currentColor" />
                                    </svg>
                                </button>
                                <button id="consult-next-btn" class="chip-button hidden" type="button" aria-label="Weiter zur naechsten Beratungsphase" title="Weiter zur naechsten Beratungsphase">
                                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M5 12h14" />
                                        <path d="M13 6l6 6-6 6" />
                                    </svg>
                                </button>
                            </div>
                        </div>
</header>
                    <div class="panel-body">
                        <section class="panel-section" data-tone="blue">
                            <header class="section-heading">
                                <h3>Gehaltseingang</h3>
                            </header>
                            <div id="sec-income" class="section-grid">
                                <div class="mlp-input">
                                    <label for="income" class="sr-only">Nettoeinkommen</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="income" value="3000" class="mlp-input-field" inputmode="decimal" placeholder="Nettoeinkommen">
                                    </div>
                                </div>
                            </div>
                        </section>
                        <section class="panel-section" data-tone="gold">
                            <header class="section-heading">
                                <h3>Konsumkonto</h3>
                                <span class="section-subtitle">Minimum &amp; Überschuss (geschätzt)</span>
                            </header>
                            <div id="sec-konsum" class="section-grid section-grid--two">
                                <div class="mlp-input">
                                    <label for="konsumMin" class="sr-only">Mindestbestand (Sockelbetrag)</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="konsumMin" value="100" class="mlp-input-field" inputmode="decimal" placeholder="Mindestbestand">
                                    </div>
                                </div>
                                <div class="mlp-input">
                                    <label for="konsumLeftover" class="sr-only">Variabler Überschuss (Schätzung)</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="konsumLeftover" value="250" class="mlp-input-field" inputmode="decimal" placeholder="Variabler Überschuss">
                                    </div>
                                </div>
                            </div>
                        </section>
                        <section class="panel-section" data-tone="teal">
                            <header class="section-heading">
                                <h3>Tagesgeldkonto</h3>
                                <span class="section-subtitle">Sparziel &amp; Bestand</span>
                            </header>
                            <div id="sec-tagesgeld" class="section-grid section-grid--two">
                                <div class="mlp-input">
                                    <label for="tagesgeldCurrent" class="sr-only">Aktueller Stand</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="tagesgeldCurrent" value="4800" class="mlp-input-field" inputmode="decimal" placeholder="Aktueller Stand">
                                    </div>
                                </div>
                                <div class="mlp-input">
                                    <label for="tagesgeldLimit" class="sr-only">Sparziel (Überlaufgrenze)</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="tagesgeldLimit" value="5000" class="mlp-input-field" inputmode="decimal" placeholder="Sparziel">
                                    </div>
                                </div>
                            </div>
                        </section>
                        <section class="panel-section" data-tone="slate">
                            <header class="section-heading">
                                <h3>Vermögensdepot</h3>
                            </header>
                            <div id="sec-prognose" class="section-stack">
                                <div class="mlp-input">
                                    <label for="depotCurrent" class="sr-only">Aktueller Depotstand</label>
                                    <div class="input-frame">
                                        <span class="input-prefix">€</span>
                                        <input type="number" id="depotCurrent" value="25000" class="mlp-input-field" inputmode="decimal" placeholder="Aktueller Depotstand">
                                    </div>
                                </div>
                                <div class="mlp-input mlp-range-group">
                                    <label for="anlagezeitraum" class="sr-only">Anlagezeitraum</label>
                                    <div class="range-meta" aria-hidden="true">
                                        <span class="range-label">Anlagezeitraum</span>
                                        <span id="anlagezeitraum-label" class="range-value">15 Jahre</span>
                                    </div>
                                    <input type="range" id="anlagezeitraum" min="1" max="30" value="15" class="mlp-range">
                                </div>
                                <div class="mlp-input">
                                    <label for="rendite" class="sr-only">Ihre angenommene Rendite p.a.</label>
                                    <div class="input-frame">
                                        <input type="number" id="rendite" step="0.1" value="7" class="mlp-input-field" inputmode="decimal" placeholder="Rendite p.a.">
                                        <span class="input-suffix">%</span>
                                    </div>
                                    <div id="rendite-info" class="section-note"></div>
                                </div>
                                <button onclick="calculateProjection()" class="btn btn-primary btn-lg btn-block">Prognose berechnen</button>
                            </div>
                        </section>
                        <section class="panel-section" data-tone="blue">
                            <header class="section-heading">
                                <span class="section-eyebrow">Timing</span>
                                <h3>Buchungskalender</h3>
                            </header>
                            <div id="sec-booking-plan" class="section-stack">
                                <div id="booking-type-buttons" class="booking-type-group"></div>
                                <div class="booking-toolbar">
                                    <button id="booking-clear-month" type="button" class="btn btn-ghost btn-sm link-danger">Plan leeren</button>
                                </div>
                                <div id="booking-calendar" class="booking-calendar" role="grid" aria-label="Buchungskalender"></div>
                                <p id="booking-hint" class="section-note"></p>
                            </div>
                        </section>
                    </div>
                    <div class="print-area">
                        <button onclick="prepareAndPrint()" class="btn btn-secondary btn-lg btn-block print-btn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <path d="M17 17h2a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h2"></path>
                                <path d="M7 21h10a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2z"></path>
                                <path d="M7 5V3a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2"></path>
                            </svg>
                            Planung als PDF drucken
                        </button>
                    </div>
                </div>
            </aside>
            <div id="flow-container" class="w-full lg:flex-grow relative min-h-[1150px]">
                <svg id="flow-svg" class="flow-svg">
                    <defs>
                      <linearGradient id="flow-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" stop-color="#3b82f6" />
                        <stop offset="100%" stop-color="#6366f1" />
                      </linearGradient>
                      <filter id="flow-glow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="3" result="blur"/>
                        <feMerge>
                          <feMergeNode in="blur"/>
                          <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                      </filter>
                      <mask id="flow-mask" maskUnits="userSpaceOnUse">
                        <rect x="0" y="0" width="100%" height="100%" fill="black"></rect>
                        <path id="flow-path-1-mask" class="flow-mask-stroke"></path>
                        <path id="flow-path-2-mask" class="flow-mask-stroke"></path>
                        <path id="konsum-tagesgeld-flow-mask" class="flow-mask-stroke"></path>
                        <path id="tagesgeld-depot-flow-mask" class="flow-mask-stroke"></path>
                        <path id="fixkosten-depot-flow-mask" class="flow-mask-stroke"></path>
                      </mask>
                    </defs>
                    <g id="flow-visuals" mask="url(#flow-mask)">
                      <path id="flow-path-1-erase" class="flow-erase"></path>
                      <path id="flow-path-1" class="flow-path"></path><path id="flow-path-1-anim" class="flow-path-animation"></path><g id="flow-path-1-dot"></g>
                      <path id="flow-path-2-erase" class="flow-erase"></path>
                      <path id="flow-path-2" class="flow-path"></path><path id="flow-path-2-anim" class="flow-path-animation"></path><g id="flow-path-2-dot"></g>
                      <path id="konsum-tagesgeld-flow-erase" class="flow-erase"></path>
                      <path id="konsum-tagesgeld-flow" class="flow-path"></path><path id="konsum-tagesgeld-flow-anim" class="flow-path-animation"></path><g id="konsum-tagesgeld-flow-dot"></g>
                      <path id="tagesgeld-depot-flow-erase" class="flow-erase"></path>
                      <path id="tagesgeld-depot-flow" class="flow-path"></path><path id="tagesgeld-depot-flow-anim" class="flow-path-animation"></path><g id="tagesgeld-depot-flow-dot"></g>
                      <path id="fixkosten-depot-flow-erase" class="flow-erase"></path>
                      <path id="fixkosten-depot-flow" class="flow-path"></path><path id="fixkosten-depot-flow-anim" class="flow-path-animation"></path><g id="fixkosten-depot-flow-dot"></g>
                    </g>
                    <path id="schutzschirm-path" class="schutzschirm"></path>
                </svg>
                <div id="gehalt-basin" class="account-basin"></div>
                <div id="fixkosten-basin" class="account-basin cursor-pointer hover:border-indigo-500" onclick="openModal('fixkosten-modal')"></div>
                <div id="konsum-basin" class="account-basin"></div>
                <div id="tagesgeld-basin" class="account-basin"></div>
                <div id="depot-basin" class="account-basin cursor-pointer hover:border-purple-500" onclick="openModal('depot-modal')"></div>
            </div>
        </div>
    </div>
    
    <div id="printable-report"></div>

    <!-- Modals -->
    <div id="prognose-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-3xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('prognose-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Prognose: Vermögensentwicklung</h3> <div class="bg-gray-900 p-4 rounded-lg"> <canvas id="prognose-chart"></canvas> </div> <div id="prognose-summary" class="mt-4 text-center"></div> </div> </div>
    <div id="fixkosten-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-2xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('fixkosten-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Fixkosten & Sparpläne</h3><div id="fixkosten-list" class="space-y-2 max-h-64 overflow-y-auto pr-2"></div> <button onclick="addFixkostenItem()" class="mt-4 text-sm bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded-md">+ Posten hinzufügen</button><hr class="border-gray-600 my-4"> <div class="flex justify-between items-center"><p class="text-lg">Monatliche Gesamtkosten:</p><p id="modal-total" class="text-2xl font-bold text-red-400">€ 0</p></div> <button onclick="saveFixkosten()" class="mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Speichern & Schließen</button> </div> </div>
    <div id="depot-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4 z-50"> <div class="bg-gray-800 w-full max-w-2xl rounded-xl shadow-2xl p-6 relative"> <button onclick="closeModal('depot-modal')" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button> <h3 class="text-xl font-bold mb-4">Depot-Aufteilung</h3><p class="text-sm text-gray-400 -mt-3 mb-4">Lege fest, wie neue Investments verteilt werden.</p> <div id="depot-list" class="space-y-2 max-h-64 overflow-y-auto pr-2"></div> <button onclick="addDepotItem()" class="mt-4 text-sm bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded-md">+ Fonds hinzufügen</button><hr class="border-gray-600 my-4"> <div class="flex justify-between items-center"><p class="text-lg">Gesamt-Verteilung:</p><p id="depot-total" class="text-2xl font-bold">100 %</p></div> <p id="depot-warning" class="text-center text-yellow-400 mt-2 h-6"></p> <button id="depot-save-button" onclick="saveDepot()" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Speichern & Schließen</button> </div> </div>

    <script>
    let currentVariant = 'A';
    
    const BOOKING_DAYS = 31;
    const BOOKING_KEY = "0";
    const bookingTypes = [
        {
            id: 'salary_to_fix',
            label: 'Gehalt → Fixkosten',
            description: 'Gehaltseingang landet auf dem Fixkostenkonto.',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3.5" y="6.5" width="7.5" height="11" rx="2"></rect><path d="M6.5 9.5h2"></path><path d="M6.5 12h1.6"></path><circle cx="16.5" cy="12" r="3"></circle><path d="M11 12h3.5"></path><path d="M14.5 10l2 2-2 2"></path></svg>`,
            accent: '#34d399',
            border: 'rgba(16, 185, 129, 0.65)',
            dayBackground: 'rgba(16, 185, 129, 0.18)',
            badgeBackground: 'rgba(16, 185, 129, 0.18)',
            badgeColor: '#34d399'
        },
        {
            id: 'standing_to_konsum',
            label: 'Fixkosten → Konsum',
            labelB: 'Konsum → Fixkosten',
            description: 'Regelmäßiger Übertrag vom Fixkostenkonto auf das Konsumkonto.',
            descriptionB: 'Regelmäßiger Übertrag vom Konsumkonto auf das Fixkostenkonto.',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M7 8h8a4 4 0 0 1 4 4v0"></path><path d="M17 10l2 2-2 2"></path><path d="M17 14h-8a4 4 0 0 1-4-4v0"></path><path d="M7 16l-2-2 2-2"></path></svg>`,
            iconB: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M17 8h-8a4 4 0 0 0-4 4v0"></path><path d="M7 10l-2 2 2 2"></path><path d="M7 14h8a4 4 0 0 0 4-4v0"></path><path d="M17 16l2-2-2-2"></path></svg>`,
            accent: '#60a5fa',
            border: 'rgba(96, 165, 250, 0.6)',
            dayBackground: 'rgba(59, 130, 246, 0.16)',
            badgeBackground: 'rgba(59, 130, 246, 0.16)',
            badgeColor: '#60a5fa'
        },
        {
            id: 'sparplan',
            label: 'Fixkosten → Sparplan',
            description: 'Sparrate wird in den Depot-Sparplan investiert.',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M5 16l4-5 3 2 5-6"></path><path d="M15.5 6.5h3v3"></path><path d="M6 18v2"></path><path d="M11 15v5"></path><path d="M16 17v3"></path></svg>`,
            accent: '#c084fc',
            border: 'rgba(168, 85, 247, 0.6)',
            dayBackground: 'rgba(168, 85, 247, 0.16)',
            badgeBackground: 'rgba(168, 85, 247, 0.18)',
            badgeColor: '#c084fc'
        },
        {
            id: 'konsum_to_tagesgeld',
            label: 'Konsum → Tagesgeld',
            description: 'Restbetrag wird auf das Tagesgeld geschoben.',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="8" r="3"></circle><path d="M12 11v7"></path><path d="M9 15l3 3 3-3"></path><path d="M6 20h12"></path></svg>`,
            accent: '#facc15',
            border: 'rgba(250, 204, 21, 0.6)',
            dayBackground: 'rgba(250, 204, 21, 0.14)',
            badgeBackground: 'rgba(250, 204, 21, 0.18)',
            badgeColor: '#facc15'
        },
        {
            id: 'tagesgeld_to_depot',
            label: 'Tagesgeld → Depot',
            description: 'Überschüsse vom Tagesgeld fließen ins Depot.',
            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M5 17h14"></path><path d="M8 17v-4"></path><path d="M12 17v-7"></path><path d="M16 17v-2"></path><path d="M12 5l-3 3h2v4h2V8h2z"></path></svg>`,
            accent: '#f97316',
            border: 'rgba(249, 115, 22, 0.6)',
            dayBackground: 'rgba(249, 115, 22, 0.16)',
            badgeBackground: 'rgba(249, 115, 22, 0.18)',
            badgeColor: '#f97316'
        }
    ];
    function getActiveBookingLabel(type) {
        if (!type) return '';
        if (currentVariant === 'B' && type.labelB) return type.labelB;
        return type.label || '';
    }

    function getActiveBookingDescription(type) {
        if (!type) return '';
        if (currentVariant === 'B' && type.descriptionB) return type.descriptionB;
        return type.description || getActiveBookingLabel(type);
    }

    function getActiveBookingIcon(type) {
        if (!type) return '';
        if (currentVariant === 'B' && type.iconB) return type.iconB;
        return type.icon || '';
    }

const bookingTypeLookup = {};
    bookingTypes.forEach((type, index) => {
        bookingTypeLookup[type.id] = Object.assign({ order: index }, type);
    });
    const bookingStorageKey = 'mlp_booking_plan_v1';
    let bookingPlan = loadBookingPlan() || createDefaultBookingPlan();
    let selectedBookingMonth = String(determineInitialBookingMonth(bookingPlan));
    let selectedBookingTypeId = bookingTypes.length ? bookingTypes[0].id : null;
    let bookingTypeButtonsEl = null;
    let bookingCalendarEl = null;
    let bookingHintEl = null;
    let bookingClearMonthBtn = null;

    function loadBookingPlan() {
        try {
            const raw = localStorage.getItem(bookingStorageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            return (parsed && typeof parsed === 'object') ? parsed : null;
        } catch (err) {
            console.warn('Buchungsplan konnte nicht geladen werden.', err);
            return null;
        }
    }

    function saveBookingPlan() {
        pruneEmptyMonths();
        try {
            localStorage.setItem(bookingStorageKey, JSON.stringify(bookingPlan));
        } catch (err) {
            console.warn('Buchungsplan konnte nicht gespeichert werden.', err);
        }
    }

    function pruneEmptyMonths() {
        Object.keys(bookingPlan).forEach(key => {
            const monthPlan = bookingPlan[key];
            if (!monthPlan || !Object.keys(monthPlan).length) {
                delete bookingPlan[key];
            }
        });
    }

    function createDefaultBookingPlan() {
        return {
            [BOOKING_KEY]: {
                '1': ['salary_to_fix'],
                '3': ['standing_to_konsum'],
                '15': ['sparplan'],
                '27': ['konsum_to_tagesgeld'],
                '28': ['tagesgeld_to_depot']
            }
        };
    }

    function determineInitialBookingMonth(plan) {
        if (plan && hasEntriesForMonth(BOOKING_KEY, plan)) return BOOKING_KEY;
        const keys = plan ? Object.keys(plan) : [];
        return keys.length ? keys[0] : BOOKING_KEY;
    }

    function hasEntriesForMonth(month, plan = bookingPlan) {
        const monthPlan = plan[String(month)];
        return !!(monthPlan && Object.keys(monthPlan).length);
    }

    function ensureMonthPlan(month) {
        const key = String(month);
        if (!bookingPlan[key]) bookingPlan[key] = {};
        return bookingPlan[key];
    }

    function renderBookingTypeButtons() {
        if (!bookingTypeButtonsEl) return;
        bookingTypeButtonsEl.innerHTML = '';
        bookingTypes.forEach(type => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'booking-type-btn';
            if (type.badgeBackground) btn.style.backgroundColor = type.badgeBackground;
            if (type.border) btn.style.borderColor = type.border;
            if (type.badgeColor) btn.style.color = type.badgeColor;
            const iconMarkup = getActiveBookingIcon(type);
            const activeLabel = getActiveBookingLabel(type);
            const activeDesc = getActiveBookingDescription(type);
            btn.innerHTML = `${iconMarkup}<span class="sr-only">${activeLabel || ''}</span>`;
            const tooltip = activeDesc || activeLabel || type.id;
            btn.title = tooltip;
            btn.setAttribute('aria-label', tooltip);
            btn.setAttribute('aria-pressed', selectedBookingTypeId === type.id ? 'true' : 'false');
            if (selectedBookingTypeId === type.id) btn.classList.add('booking-type-btn-active');
            btn.addEventListener('click', () => handleBookingTypeSelect(type.id));
            bookingTypeButtonsEl.appendChild(btn);
        });
    }

    function handleBookingTypeSelect(typeId) {
        if (selectedBookingTypeId === typeId) return;
        selectedBookingTypeId = typeId;
        renderBookingTypeButtons();
        updateBookingHint();
    }

    function renderBookingCalendar() {
        if (!bookingCalendarEl) return;
        bookingCalendarEl.innerHTML = '';
        const monthPlan = ensureMonthPlan(selectedBookingMonth);
        for (let day = 1; day <= BOOKING_DAYS; day++) {
            const dayKey = String(day);
            const entries = Array.isArray(monthPlan[dayKey]) ? monthPlan[dayKey] : [];
            const cell = document.createElement('div');
            cell.className = 'booking-day';
            if (day >= 29) cell.classList.add('booking-day--overflow');
            cell.dataset.day = dayKey;
            cell.setAttribute('role', 'button');
            cell.setAttribute('tabindex', '0');
            cell.addEventListener('click', () => toggleDayBooking(day));
            cell.addEventListener('keydown', evt => {
                if (evt.key === 'Enter' || evt.key === ' ') {
                    evt.preventDefault();
                    toggleDayBooking(day);
                }
            });
            const number = document.createElement('div');
            number.className = 'booking-day-number';
            number.textContent = String(day);
            cell.appendChild(number);
            const content = document.createElement('div');
            content.className = 'booking-day-content';
            cell.appendChild(content);
            if (entries.length) {
                cell.classList.add('has-booking');
                const dominant = getBookingType(entries[0]);
                if (dominant && dominant.dayBackground) cell.style.backgroundColor = dominant.dayBackground;
                if (dominant && dominant.border) cell.style.borderColor = dominant.border;
            } else {
                cell.style.backgroundColor = '';
                cell.style.borderColor = '';
            }
            entries.slice().sort((a, b) => getTypeOrder(a) - getTypeOrder(b)).forEach(typeId => {
                const type = getBookingType(typeId);
                if (!type) return;
                const iconBtn = document.createElement('button');
                iconBtn.type = 'button';
                iconBtn.className = 'booking-entry-btn';
                const entryIcon = getActiveBookingIcon(type) || type.icon || '';
                const entryLabel = getActiveBookingLabel(type) || type.label || '';
                iconBtn.innerHTML = entryIcon;
                const removeTooltip = entryLabel ? `${entryLabel} entfernen` : 'Aktion entfernen';
                iconBtn.title = removeTooltip;
                iconBtn.setAttribute('aria-label', entryLabel ? `${entryLabel} am Tag ${day} entfernen` : `Aktion am Tag ${day} entfernen`);
                if (type.badgeBackground) iconBtn.style.backgroundColor = type.badgeBackground;
                if (type.badgeColor) iconBtn.style.color = type.badgeColor;
                iconBtn.addEventListener('click', evt => {
                    evt.stopPropagation();
                    removeBookingFromDay(day, typeId);
                });
                content.appendChild(iconBtn);
            });
            bookingCalendarEl.appendChild(cell);
        }
        updateClearButtonState();
    }

    function getTypeOrder(typeId) {
        const type = getBookingType(typeId);
        return typeof type?.order === 'number' ? type.order : Number.MAX_SAFE_INTEGER;
    }

    function toggleDayBooking(day) {
        if (!selectedBookingTypeId) {
            updateBookingHint('Waehle zuerst einen Buchungstyp.');
            return;
        }
        const type = getBookingType(selectedBookingTypeId);
        if (!type) return;
        const monthPlan = ensureMonthPlan(selectedBookingMonth);
        const key = String(day);
        let items = monthPlan[key];
        if (!Array.isArray(items)) {
            items = [];
            monthPlan[key] = items;
        }
        const idx = items.indexOf(selectedBookingTypeId);
        if (idx >= 0) {
            items.splice(idx, 1);
        } else {
            items.push(selectedBookingTypeId);
            items.sort((a, b) => getTypeOrder(a) - getTypeOrder(b));
        }
        if (!items.length) delete monthPlan[key];
        saveBookingPlan();
        renderBookingCalendar();
        updateBookingHint();
    }

    function removeBookingFromDay(day, typeId) {
        const monthPlan = bookingPlan[String(selectedBookingMonth)];
        if (!monthPlan) return;
        const key = String(day);
        const items = monthPlan[key];
        if (!Array.isArray(items)) return;
        const idx = items.indexOf(typeId);
        if (idx >= 0) items.splice(idx, 1);
        if (!items.length) delete monthPlan[key];
        saveBookingPlan();
        renderBookingCalendar();
        updateBookingHint();
    }

    function updateBookingHint(message) {
        if (!bookingHintEl) return;
        if (message) {
            bookingHintEl.textContent = message;
            return;
        }
        if (!selectedBookingTypeId) {
            bookingHintEl.textContent = 'Waehle einen Buchungstyp und klicke auf den passenden Tag.';
            return;
        }
        const type = getBookingType(selectedBookingTypeId);
        const activeLabel = getActiveBookingLabel(type);
        bookingHintEl.innerHTML = `Aktiver Typ: <span class="booking-hint-strong">${activeLabel || ''}</span>. Klicke auf einen Tag, um ihn hinzufuegen oder zu entfernen.`;
    }

    function clearCurrentMonthPlan() {
        const key = String(selectedBookingMonth);
        if (bookingPlan[key]) {
            bookingPlan[key] = {};
            saveBookingPlan();
            renderBookingCalendar();
            updateBookingHint();
        }
    }

    function updateClearButtonState() {
        if (!bookingClearMonthBtn) return;
        const hasEntries = hasEntriesForMonth(selectedBookingMonth);
        bookingClearMonthBtn.disabled = !hasEntries;
        bookingClearMonthBtn.classList.toggle('opacity-50', !hasEntries);
        bookingClearMonthBtn.classList.toggle('cursor-not-allowed', !hasEntries);
    }

    function getBookingType(typeId) {
        return bookingTypeLookup[typeId];
    }

    function setupBookingPlanner() {
        bookingTypeButtonsEl = getEl('booking-type-buttons');
        bookingCalendarEl = getEl('booking-calendar');
        bookingHintEl = getEl('booking-hint');
        bookingClearMonthBtn = getEl('booking-clear-month');
        if (!bookingTypeButtonsEl || !bookingCalendarEl) return;
        renderBookingTypeButtons();
        renderBookingCalendar();
        updateBookingHint();
        if (bookingClearMonthBtn) {
            bookingClearMonthBtn.addEventListener('click', clearCurrentMonthPlan);
        }
    }

let fixkostenItems = [ 
        { name: 'Miete', amount: 850, interval: 'monthly', target: 'fixkosten' }, 
        { name: 'Strom', amount: 60, interval: 'monthly', target: 'fixkosten' }, 
        { name: 'Kommunikation (Handy/Netz)', amount: 40, interval: 'monthly', target: 'fixkosten' },
        { name: 'Mobilität (Auto/Ticket)', amount: 150, interval: 'monthly', target: 'fixkosten' },
        { name: 'Versicherungen', amount: 180, interval: 'quarterly', target: 'fixkosten' }, 
        { name: 'Sport/Hobbies', amount: 50, interval: 'monthly', target: 'fixkosten' },
        { name: 'Vorsorge (z.B. BU)', amount: 70, interval: 'monthly', target: 'fixkosten' },
        { name: 'Sparplan Depot', amount: 250, interval: 'monthly', target: 'depot' }, 
    ];
    let depotItems = [ { name: 'MSCI World ETF', allocation: 70, color: '#3b82f6' }, { name: 'Emerging Markets ETF', allocation: 30, color: '#8b5cf6' } ];
    let prognoseChartInstance = null;
    // Beratungsansicht state
    let consultationMode = false;      // off by default
    let consultationStep = 0;          // 0..5 per variant
    let allowDepotStream = true;       // normal mode shows depot stream

    function setConsultationMode(on) {
      consultationMode = !!on;
      consultationStep = on ? 1 : 0;
      allowDepotStream = !on; // only enable depot stream at step 5 in consultation
      applyConsultationVisibility();
      calculateAndUpdate();
      const nextBtn = getEl('consult-next-btn');
      const toggleBtn = getEl('consult-toggle-btn');
      const consultChip = toggleBtn ? toggleBtn.closest('.control-chip--consultation') : null;
      if (on) {
        if (nextBtn) nextBtn.classList.remove('hidden');
        if (toggleBtn) { toggleBtn.setAttribute('aria-label', 'Beratung beenden'); toggleBtn.setAttribute('title', 'Beratung beenden'); }
        if (consultChip) consultChip.classList.add('is-active');
      } else {
        if (nextBtn) nextBtn.classList.add('hidden');
        if (toggleBtn) { toggleBtn.setAttribute('aria-label', 'Beratung starten'); toggleBtn.setAttribute('title', 'Beratung starten'); }
        if (consultChip) consultChip.classList.remove('is-active');
      }
    }

    function nextConsultationStep() {
      if (!consultationMode) return;
      consultationStep = Math.min(5, consultationStep + 1);
      if (consultationStep === 5) allowDepotStream = true; // enable depot stream only at final step
      applyConsultationVisibility();
      calculateAndUpdate();
    }

    function isVisible(el) {
      return el && el.offsetParent !== null; // hidden via CSS class will report null
    }

    function show(el, on) {
      if (!el) return;
      if (on) el.classList.remove('hidden'); else el.classList.add('hidden');
    }

    function applyConsultationVisibility() {
      const secIncome = getEl('sec-income');
      const secKonsum = getEl('sec-konsum');
      const secTG     = getEl('sec-tagesgeld');
      const secProg   = getEl('sec-prognose');

      // Default: all visible (normal mode)
      if (!consultationMode) {
        [secIncome, secKonsum, secTG, secProg].forEach(el => show(el, true));
        // all basins visible
        for (const key in basins) show(basins[key], true);
        return;
      }

      const A = (currentVariant === 'A');
      // Step visibility by variant
      if (A) {
        show(secIncome, true);
        show(secKonsum, consultationStep >= 2);
        show(secTG,     consultationStep >= 3);
        show(secProg,   consultationStep >= 4);

        show(basins.gehalt, true);
        show(basins.fixkosten, true);
        show(basins.konsum, consultationStep >= 2);
        show(basins.tagesgeld, consultationStep >= 3);
        show(basins.depot, consultationStep >= 4);
      } else {
        show(secIncome, true);
        show(secKonsum, true); // B: income + konsum from step 1
        show(secTG,     consultationStep >= 3);
        show(secProg,   consultationStep >= 4);

        show(basins.gehalt, true);
        show(basins.konsum, true);
        show(basins.fixkosten, consultationStep >= 2);
        show(basins.tagesgeld, consultationStep >= 3);
        show(basins.depot, consultationStep >= 4);
      }
    }
    
    const renditeData = {
        1: {min: -40, max: 50}, 5: {min: -12, max: 32}, 10: {min: -1.5, max: 19},
        15: {min: 3, max: 15}, 20: {min: 4, max: 13}, 25: {min: 5, max: 12}, 30: {min: 6, max: 11}
    };
    // === Load fine-grained min/max returns from TXT (MLP Renditedreieck) ===
    // File: data/rendite_extreme_generated.txt
    // Format (tab/whitespace):
    // Anlagezeitraum (Jahre)    Minimale Rendite (%)   Maximale Rendite (%)
    // 1   -42.2   51.7
    let renditeExtremes = null;

    async function loadRenditeExtremes() {
    try {
        const res = await fetch('data/rendite_extreme_generated.txt', { cache: 'no-store' });
        if (!res.ok) throw new Error('not found');
        const txt = await res.text();
        renditeExtremes = parseRenditeExtremesTSV(txt);
        // refresh UI for current slider value
        const jahre = parseInt(inputs.anlagezeitraum.value, 10);
        updateRenditeSuggestions(jahre);
    } catch (e) {
        console.warn('Rendite-Extremwerte nicht geladen, nutze Fallback.', e);
        renditeExtremes = null;
    }
    }

    function parseRenditeExtremesTSV(tsv) {
    const map = {};
    tsv.split(/\r?\n/).forEach(line => {
        const trimmed = line.trim();
        if (!trimmed) return;
        if (!/^\d+/.test(trimmed)) return; // skip header
        const parts = trimmed.split(/\t|\s+/).filter(Boolean);
        if (parts.length < 3) return;
        const years = parseInt(parts[0], 10);
        const min = parseFloat(String(parts[1]).replace(',', '.'));
        const max = parseFloat(String(parts[2]).replace(',', '.'));
        if (Number.isFinite(years) && Number.isFinite(min) && Number.isFinite(max)) {
        map[years] = { min: +min.toFixed(1), max: +max.toFixed(1) };
        }
    });
    return map;
    }

    let inputs, basins, flowContainer; // Declare globally, assign in DOMContentLoaded
    const getEl = (id) => document.getElementById(id);
    const formatCurrency = (val) => new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(val);
    const getMonthlyAmount = (item) => { const a = item.amount || 0; switch (item.interval) { case 'quarterly': return a / 3; case 'annually': return a / 12; default: return a; } };

function renderBasin(element, title, value, icon, subtext = '', { current = 0, min = 0, limit = Infinity, minScaleBase = null } = {}, specialContent = '') {
    // Fill height is only meaningful when a real capacity limit is provided
    const fillPercent = (limit > 0 && limit !== Infinity)
      ? Math.min(100, (current / limit) * 100)
      : 0;

    // The yellow minimum line can be scaled against an explicit base (minScaleBase),
    // falling back to the same limit if none provided. This allows Konsumkonto to
    // scale its Min-Linie gegen den monatlichen Überschuss statt gegen das Kartenlimit.
    const baseForMin = (minScaleBase != null && isFinite(minScaleBase) && minScaleBase > 0)
      ? minScaleBase
      : ((limit > 0 && limit !== Infinity) ? limit : null);
    const minPercent = baseForMin ? Math.min(100, (min / baseForMin) * 100) : 0;
    element.innerHTML = `
        <div class="absolute inset-0 bg-sky-500/30 rounded-lg transition-all duration-500" style="height: ${fillPercent}%; top: auto; bottom: 0;"></div>
        ${min > 0 ? `<div class="limit-line bg-yellow-500/70 border-t-2 border-dashed border-yellow-400" style="bottom: ${minPercent}%;"><span class="text-yellow-300">Min</span></div>` : ''}
        ${limit > 0 && limit !== Infinity ? `<div class="limit-line bg-green-500/70" style="bottom: 100%;"><span class="text-green-300">Max</span></div>` : ''}
        ${limit > 0 && limit !== Infinity && /Tagesgeldkonto/i.test(title) ? `<div class="absolute top-1 right-2 text-xs text-gray-400">Sparziel: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(limit)}</div>` : ''}
        <div class="relative z-10 flex flex-col items-center justify-center h-full">
          ${specialContent || icon}
          <p class="font-bold">${title}</p>
          <p class="text-lg font-mono">${value}</p>
          ${subtext ? `<p class="text-xs text-gray-400 mt-1">${subtext}</p>` : ''}
        </div>
    `;
    }

    function positionCascade() {
        if (!flowContainer) return;
        const containerWidth = flowContainer.clientWidth;
        const h_gap_side = 120;
        const v_gap = 240;
        const depotWidth = 440;
        basins.depot.style.width = `${depotWidth}px`;

        let positions;
        if (currentVariant === 'B') {
            positions = {
                gehalt:   { top: 0,          left: containerWidth / 2 - basins.gehalt.offsetWidth / 2 },
                // Karten näher zur Mitte rücken (symmetrisch)
                konsum:   { top: v_gap,      left: containerWidth / 2 - basins.konsum.offsetWidth - h_gap_side },
                fixkosten:{ top: v_gap * 2,  left: containerWidth / 2 + h_gap_side },
                tagesgeld:{ top: v_gap * 3,  left: containerWidth / 2 - basins.tagesgeld.offsetWidth / 2 },
                depot:    { top: v_gap * 4.0, left: containerWidth / 2 - depotWidth / 2 },
            };
        } else { // Variante A
            positions = {
                gehalt:   { top: 0,          left: containerWidth / 2 - basins.gehalt.offsetWidth / 2 },
                // Karten näher zur Mitte rücken (symmetrisch)
                fixkosten:{ top: v_gap,      left: containerWidth / 2 + h_gap_side },
                konsum:   { top: v_gap * 2,  left: containerWidth / 2 - basins.konsum.offsetWidth - h_gap_side },
                tagesgeld:{ top: v_gap * 3,  left: containerWidth / 2 - basins.tagesgeld.offsetWidth / 2 },
                depot:    { top: v_gap * 4.0, left: containerWidth / 2 - depotWidth / 2 },
            };
        }
        for (const key in basins) { 
            if (basins[key]) {
                basins[key].style.top = `${positions[key].top}px`; 
                basins[key].style.left = `${positions[key].left}px`; 
            }
        }
    }

    function attachFlowDot(pathId, radius = 4, speedSec = 3) {
        const dotGroupId = `${pathId}-dot`;
        let g = document.getElementById(dotGroupId);
        if (!g) {
            g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', dotGroupId);
            document.getElementById('flow-svg').appendChild(g);
        }
        // Clear existing content
        g.innerHTML = '';
        // Create circle + animateMotion referencing the path
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('class', 'flow-dot');
        circle.setAttribute('r', String(radius));
        const animateMotion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
        animateMotion.setAttribute('dur', `${Math.max(1.2, speedSec)}s`);
        animateMotion.setAttribute('repeatCount', 'indefinite');
        const mpath = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
        mpath.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', `#${pathId}`);
        animateMotion.appendChild(mpath);
        circle.appendChild(animateMotion);
        g.appendChild(circle);
    }

    function drawFlow(pathId, fromBasin, toBasin, value, maxFlowValue, labelText = '') {
        if (!fromBasin || !toBasin) return;
        const path = getEl(pathId), pathAnim = getEl(`${pathId}-anim`);
        const fromRect = fromBasin.getBoundingClientRect(), toRect = toBasin.getBoundingClientRect(), containerRect = flowContainer.getBoundingClientRect();
        let fromX = fromRect.left - containerRect.left + fromRect.width / 2;
        let fromY = fromRect.bottom - containerRect.top;
        const toX = toRect.left - containerRect.left + toRect.width / 2;
        const toY = toRect.top - containerRect.top;
        const minWidth = 10, maxWidth = 45;
        const normalizedValue = Math.max(0, value) / maxFlowValue;
        const strokeWidth = minWidth + normalizedValue * (maxWidth - minWidth);
        path.style.strokeWidth = `${value > 0 ? Math.max(minWidth, strokeWidth) : 0}px`;

        let pathData;
        // REPLACED BLOCK: custom anchor, curve, and offsets for each flow
        // --- BEGIN NEW BLOCK ---
        const EXIT_OFFSET_Y = 8; // slightly deeper anchor, hides seams better
        const CURVE_MAIN = 70;   // smaller curve radius for tighter, calmer streams
        const CURVE_SHORT = 55;  // short bends for side-to-side connections

        if (pathId === 'fixkosten-depot-flow') {
            // From right side of fixkosten into right half of depot
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.75;
            const toDepotX = toRect.left - containerRect.left + toRect.width * 0.75;
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + 70} ${toDepotX},${toY - 70} ${toDepotX},${toY}`;
        } else if (pathId === 'tagesgeld-depot-flow') {
            // From center of tagesgeld into left half of depot
            const toDepotX = toRect.left - containerRect.left + (toRect.width * 0.25);
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + 55} ${toDepotX},${toY - 55} ${toDepotX},${toY}`;
        } else if (pathId === 'konsum-tagesgeld-flow') {
            // Überschuss-Stream aus dem Konsumkonto:
            //  • Variante B: unten links aus dem Konsumkonto starten (verhindert Kreuzungen)
            //  • Variante A: unten rechts aus dem Konsumkonto starten (spiegelbildlich zur Anordnung)
            if (typeof currentVariant !== 'undefined' && currentVariant === 'B') {
                // bottom-left anchor on Konsum → Tagesgeld (zentral) mit kurzer, ruhiger Kurve
                fromX = fromRect.left - containerRect.left + fromRect.width * 0.20;
                fromY -= EXIT_OFFSET_Y;
                const c1x = fromX - 40, c1y = fromY + CURVE_SHORT;
                const c2x = toX - 20,  c2y = toY - CURVE_SHORT;
                pathData = `M ${fromX},${fromY} C ${c1x},${c1y} ${c2x},${c2y} ${toX},${toY}`;
            } else {
                // Variante A: bottom-right anchor (spiegelbildlich), kurze, sanfte Biegung
                fromX = fromRect.left - containerRect.left + fromRect.width * 0.80;
                fromY -= EXIT_OFFSET_Y;
                const c1x = fromX + 40, c1y = fromY + CURVE_SHORT;
                const c2x = toX + 20,  c2y = toY - CURVE_SHORT;
                pathData = `M ${fromX},${fromY} C ${c1x},${c1y} ${c2x},${c2y} ${toX},${toY}`;
            }
        // --- BEGIN NEW BLOCK ---
        } else if (pathId === 'flow-path-2' && typeof currentVariant !== 'undefined' && currentVariant === 'A') {
            // Dauerauftrag: from left side of Fixkosten (right column) to right side of Konsum (left column)
            const R = 65; // curve radius
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.20; // exit left
            fromY -= EXIT_OFFSET_Y;
            const toKonsumX = toRect.left - containerRect.left + toRect.width * 0.80; // enter right
            pathData = `M ${fromX},${fromY} C ${fromX - R},${fromY + R} ${toKonsumX + R},${toY - R} ${toKonsumX},${toY}`;
        } else if (pathId === 'flow-path-2' && typeof currentVariant !== 'undefined' && currentVariant === 'B') {
            // Dauerauftrag: from right side of Konsum (left column) to right-half of Fixkosten (right column)
            const R = 65; // curve radius
            fromX = fromRect.left - containerRect.left + fromRect.width * 0.80; // exit right
            fromY -= EXIT_OFFSET_Y;
            const toRightX = toRect.left - containerRect.left + toRect.width * 0.75; // enter right half
            pathData = `M ${fromX},${fromY} C ${fromX + R},${fromY + R} ${toRightX - R},${toY - R} ${toRightX},${toY}`;
        } else {
            // Default smooth S-curve between centers
            fromY -= EXIT_OFFSET_Y;
            pathData = `M ${fromX},${fromY} C ${fromX},${fromY + CURVE_MAIN} ${toX},${toY - CURVE_MAIN} ${toX},${toY}`;
        }
        // --- END NEW BLOCK ---
        path.setAttribute('d', pathData); pathAnim.setAttribute('d', pathData);

        // Update mask stroke to define visible river area
        const pathMask = getEl(`${pathId}-mask`);
        if (pathMask) {
            pathMask.setAttribute('d', pathData);
            const maskWidth = Math.max(0, parseFloat(path.style.strokeWidth || "0") + 2);
            pathMask.style.strokeWidth = `${maskWidth}px`;
        }

        // Eraser path covers any legacy underlay (stroke slightly wider than main)
        const pathErase = getEl(`${pathId}-erase`);
        if (pathErase) {
            pathErase.setAttribute('d', pathData);
            const eraseWidth = Math.max(0, parseFloat(path.style.strokeWidth || "0") + 40); // extra wide to fully cover any underlay, even at tight bends
            pathErase.style.strokeWidth = `${eraseWidth}px`;
        }

        // Add/update moving dot for direction cue
        const radius = Math.max(2, Math.min(5, parseFloat(path.style.strokeWidth) / 6));
        const speed = 6 + Math.max(0, (parseFloat(path.style.strokeWidth) - 10) / 8); // overall slower, more uniform
        attachFlowDot(pathId, radius, speed);
        
        const valueLabelId = `${pathId}-value`, textLabelId = `${pathId}-text`;
        let valueLabel = getEl(valueLabelId), textLabel = getEl(textLabelId);
        if (!valueLabel) { valueLabel = document.createElement('div'); valueLabel.className = 'flow-value'; valueLabel.id = valueLabelId; flowContainer.appendChild(valueLabel); }
        if (labelText && !textLabel) { textLabel = document.createElement('div'); textLabel.className = 'flow-label'; textLabel.id = textLabelId; flowContainer.appendChild(textLabel); }
        
        valueLabel.textContent = formatCurrency(value);
        if(textLabel) textLabel.textContent = labelText;
        const midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        valueLabel.style.left = `${midPoint.x}px`; valueLabel.style.top = `${midPoint.y}px`;
        if (textLabel) {
            textLabel.style.left = `${midPoint.x}px`;
            textLabel.style.top  = `${midPoint.y - 36}px`; // clearer separation above the amount pill
        }
        path.classList.toggle('active', value > 0);
        valueLabel.style.display = (value > 0) ? 'block' : 'none';
        if(textLabel) textLabel.style.display = (value > 0) ? 'block' : 'none';
    }

    function hideFlow(pathId) {
        const path      = getEl(pathId);
        const pathAnim  = getEl(`${pathId}-anim`);
        const valueLbl  = getEl(`${pathId}-value`);
        const textLbl   = getEl(`${pathId}-text`);
        const pathErase = getEl(`${pathId}-erase`);
        const pathMask  = getEl(`${pathId}-mask`);
        const dotGroup  = getEl(`${pathId}-dot`);
        if (path) {
            path.classList.remove('active');
            path.style.strokeWidth = '0px';
        }
        if (pathAnim) {
            pathAnim.style.opacity = '0';
        }
        if (valueLbl) valueLbl.style.display = 'none';
        if (textLbl)  textLbl.style.display  = 'none';
        if (pathErase) pathErase.style.strokeWidth = '0px';
        if (pathMask)  pathMask.style.strokeWidth  = '0px';
        if (dotGroup)  dotGroup.innerHTML = '';
    }

    function drawSchutzschirm(fromBasin, toBasin) {
        if (!fromBasin || !toBasin) return;
        const path = getEl('schutzschirm-path');
        const toRect = toBasin.getBoundingClientRect(), containerRect = flowContainer.getBoundingClientRect();
        const toLeftX = toRect.left - containerRect.left, toRightX = toRect.right - containerRect.left, toY = toRect.top - containerRect.top;
        const controlX = toLeftX + toRect.width / 2;
        const controlY = toY - 80;
        const pathData = `M ${toLeftX}, ${toY} Q ${controlX}, ${controlY} ${toRightX}, ${toY}`;
        path.setAttribute('d', pathData);
    }
    
    function calculateAndUpdate() {
        requestAnimationFrame(() => {
            positionCascade();
            const income = parseFloat(inputs.income.value) || 0, konsumMin = parseFloat(inputs.konsumMin.value) || 0, konsumLeftover = parseFloat(inputs.konsumLeftover.value) || 0;
            const tagesgeldCurrent = parseFloat(inputs.tagesgeldCurrent.value) || 0, tagesgeldLimit = parseFloat(inputs.tagesgeldLimit.value) || 0;
            const fixkostenOnlyTotal = fixkostenItems.filter(i => i.target === 'fixkosten').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
            const depotSparplanTotal = fixkostenItems.filter(i => i.target === 'depot').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
            const totalAbgang = fixkostenOnlyTotal + depotSparplanTotal;
            // Zufluss (Inflow) in das Konsumkonto zur Skalierung der Min-Linie
            const konsumInflow = (currentVariant === 'A')
              ? Math.max(0, income - totalAbgang)   // Variante A: nach Abzug aller Abgänge (Fix + Sparplan)
              : Math.max(0, income);                // Variante B: Gehalt geht direkt auf Konsum
            const { tagesgeldInflow, depotOverflow } = calculateOverflow(konsumLeftover, tagesgeldCurrent, tagesgeldLimit);
            const finalTagesgeld = tagesgeldCurrent + tagesgeldInflow;
            const totalDepotInflow = depotSparplanTotal + depotOverflow;
            
            let konsumValue;
            if(currentVariant === 'A') {
                konsumValue = income - totalAbgang;
            } else {
                konsumValue = income - totalAbgang;
            }
            
            renderBasin(basins.gehalt, 'Gehaltseingang', formatCurrency(income), '<svg class="w-7 h-7 mb-1 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>');
            renderBasin(basins.fixkosten, 'Fixkostenkonto', formatCurrency(totalAbgang), '<svg class="w-7 h-7 mb-1 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>', '(Klick zum Bearbeiten)');
            // Scale the yellow min line relative to the available monthly surplus (Überschuss).
            renderBasin(
              basins.konsum,
              'Konsumkonto',
              formatCurrency(konsumValue),
              '<svg class="w-7 h-7 mb-1 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>',
              `Überschuss: ${formatCurrency(konsumLeftover)}`,
              { current: konsumValue, min: konsumMin, limit: Infinity, minScaleBase: konsumInflow }
            );
            renderBasin(basins.tagesgeld, 'Tagesgeldkonto', formatCurrency(finalTagesgeld), '<svg class="w-7 h-7 mb-1 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path></svg>', `Zufluss: ${formatCurrency(tagesgeldInflow)}`, { current: finalTagesgeld, min: 0, limit: tagesgeldLimit });
            renderBasin(basins.depot, 'Vermögensaufbau', `+ ${formatCurrency(totalDepotInflow)}`, '', '(Klick zum Bearbeiten)', {}, createGrowthChartSVG());
            
            // === BEGIN: Flow visibility control (consultation-aware) ===
            const bothVisible = (a, b) => isVisible(a) && isVisible(b);
            const maxFlow = income || 1;

            let show1 = false, show2 = false, showKTG = false, showTGDepot = false, showFixDepot = false;

            if (currentVariant === 'A') {
                // A: Gehalt -> Fixkosten -> Konsum -> Tagesgeld -> Depot; Sparrate erst Step 5
                show1       = bothVisible(basins.gehalt,   basins.fixkosten);                                      // Step 1+
                show2       = bothVisible(basins.fixkosten, basins.konsum)   && (!consultationMode || consultationStep >= 2);
                showKTG     = bothVisible(basins.konsum,    basins.tagesgeld) && (!consultationMode || consultationStep >= 3);
                showTGDepot = bothVisible(basins.tagesgeld, basins.depot)     && (!consultationMode || consultationStep >= 4);
                showFixDepot= bothVisible(basins.fixkosten, basins.depot)     && (allowDepotStream === true); // Step 5 in consultation

                if (show1)       drawFlow('flow-path-1', basins.gehalt,    basins.fixkosten, income, maxFlow);
                else             hideFlow('flow-path-1');

                if (show2)       drawFlow('flow-path-2', basins.fixkosten, basins.konsum, Math.max(0, income - totalAbgang), maxFlow, 'Dauerauftrag');
                else             hideFlow('flow-path-2');

                if (showKTG)     drawFlow('konsum-tagesgeld-flow', basins.konsum,    basins.tagesgeld, konsumLeftover, maxFlow);
                else             hideFlow('konsum-tagesgeld-flow');

                if (showTGDepot) drawFlow('tagesgeld-depot-flow', basins.tagesgeld,  basins.depot, depotOverflow, maxFlow);
                else             hideFlow('tagesgeld-depot-flow');

                if (showFixDepot)drawFlow('fixkosten-depot-flow', basins.fixkosten,  basins.depot, depotSparplanTotal, maxFlow, 'Sparrate');
                else             hideFlow('fixkosten-depot-flow');

            } else {
                // B: Gehalt -> Konsum -> Fixkosten -> Tagesgeld -> Depot; Sparrate erst Step 5
                show1       = bothVisible(basins.gehalt,   basins.konsum);                                        // Step 1+
                show2       = bothVisible(basins.konsum,   basins.fixkosten) && (!consultationMode || consultationStep >= 2);
                showKTG     = bothVisible(basins.konsum,   basins.tagesgeld) && (!consultationMode || consultationStep >= 3);
                showTGDepot = bothVisible(basins.tagesgeld,basins.depot)    && (!consultationMode || consultationStep >= 4);
                showFixDepot= bothVisible(basins.fixkosten,basins.depot)    && (allowDepotStream === true); // Step 5 in consultation

                if (show1)       drawFlow('flow-path-1', basins.gehalt,  basins.konsum, income, maxFlow);
                else             hideFlow('flow-path-1');

                if (show2)       drawFlow('flow-path-2', basins.konsum,  basins.fixkosten, totalAbgang, maxFlow, 'Dauerauftrag');
                else             hideFlow('flow-path-2');

                if (showKTG)     drawFlow('konsum-tagesgeld-flow', basins.konsum,   basins.tagesgeld, konsumLeftover, maxFlow);
                else             hideFlow('konsum-tagesgeld-flow');

                if (showTGDepot) drawFlow('tagesgeld-depot-flow', basins.tagesgeld, basins.depot, depotOverflow, maxFlow);
                else             hideFlow('tagesgeld-depot-flow');

                if (showFixDepot)drawFlow('fixkosten-depot-flow', basins.fixkosten, basins.depot, depotSparplanTotal, maxFlow, 'Sparrate');
                else             hideFlow('fixkosten-depot-flow');
            }
            // === END: Flow visibility control ===
            drawSchutzschirm(basins.tagesgeld, basins.depot);
            // --- Shield visibility based on available liquidity on Tagesgeld, scaled by liquidity level ---
            const shield = getEl('schutzschirm-path');
            if (shield) {
                // Sichtbarkeit des Schutzschirms: sobald im Tagesgeld verwertbare Liquidität vorhanden ist
                const liquidity = Math.max(0, finalTagesgeld); // verfügbare Liquidität auf TG
                let strength = 0;
                if (isFinite(tagesgeldLimit) && tagesgeldLimit > 0) {
                    strength = Math.min(1, liquidity / tagesgeldLimit); // skaliert relativ zum Ziel
                } else {
                    strength = liquidity > 0 ? 1 : 0; // ohne Ziel: binär
                }
                if (strength > 0) {
                    // weiche Skalierung für Sichtbarkeit/Strichstärke
                    const opacity = Math.max(0.25, 0.15 + 0.85 * strength);
                    shield.style.opacity = String(opacity);
                    shield.style.strokeWidth = `${2 + 2 * strength}px`;
                } else {
                    shield.style.opacity = '0';
                }
            }
        });
    }
    
    // --- Projection Logic ---
    function calculateProjection() {
        const initialDepot = parseFloat(inputs.depotCurrent.value) || 0;
        const years = parseInt(inputs.anlagezeitraum.value, 10);
        const depotSparplanTotal = fixkostenItems.filter(i => i.target === 'depot').reduce((sum, i) => sum + getMonthlyAmount(i), 0);
        const tagesgeldCurrent = parseFloat(inputs.tagesgeldCurrent.value) || 0;
        const tagesgeldLimit = parseFloat(inputs.tagesgeldLimit.value) || 0;
        const konsumLeftover = parseFloat(inputs.konsumLeftover.value) || 0;
        const { depotOverflow } = calculateOverflow(konsumLeftover, tagesgeldCurrent, tagesgeldLimit);
        const monthlyInvestment = depotSparplanTotal + depotOverflow;
        const dataRange = getRenditeDataForPeriod(years);
        const returnAvg = parseFloat(inputs.rendite.value) / 100;
        const returnMin = dataRange.min / 100;
        const returnMax = dataRange.max / 100;
        const dataAvg = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnAvg);
        const dataMin = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnMin);
        const dataMax = calculateCompoundInterest(initialDepot, monthlyInvestment, years, returnMax);

        displayProjectionChart({
            labels: dataAvg.labels,
            datasets: [
                { label: 'Pessimistisch', data: dataMin.capitalData, color: '#ef4444' },
                { label: 'Erwartet', data: dataAvg.capitalData, color: '#3b82f6' },
                { label: 'Optimistisch', data: dataMax.capitalData, color: '#22c55e' },
                { label: 'Einzahlungen', data: dataAvg.contributionsData, color: '#6b7280' }
            ]
        });
        const summaryEl = getEl('prognose-summary');
        summaryEl.innerHTML = `
            <p>Nach <span class="font-bold">${years} Jahren</span> könnte dein Vermögen zwischen <span class="font-bold text-red-400">${formatCurrency(dataMin.totalCapital)}</span> und <span class="font-bold text-green-400">${formatCurrency(dataMax.totalCapital)}</span> liegen.</p>
            <p>Deine erwartete Prognose liegt bei <span class="font-bold text-blue-400 text-lg">${formatCurrency(dataAvg.totalCapital)}</span>, basierend auf ${formatCurrency(dataAvg.totalContributions)} Einzahlungen.</p>
        `;
        openModal('prognose-modal');
    }
    
    function calculateCompoundInterest(initial, monthly, years, annualRate) {
        const monthlyRate = annualRate / 12;
        let totalCapital = initial;
        let totalContributions = initial;
        const labels = ['Start'];
        const capitalData = [initial];
        const contributionsData = [initial];

        for (let i = 1; i <= years; i++) {
            for (let j = 0; j < 12; j++) {
                totalCapital = totalCapital * (1 + monthlyRate) + monthly;
                totalContributions += monthly;
            }
            labels.push(`Jahr ${i}`);
            capitalData.push(totalCapital);
            contributionsData.push(totalContributions);
        }
        return { labels, capitalData, contributionsData, totalCapital, totalContributions };
    }

    function displayProjectionChart({labels, datasets}) {
        const ctx = getEl('prognose-chart').getContext('2d');
        if (prognoseChartInstance) { prognoseChartInstance.destroy(); }
        
        const chartDatasets = datasets.map(ds => {
            // Custom styling for pessimistic and optimistic
            if (ds.label === 'Pessimistisch') {
                return {
                    label: ds.label,
                    data: ds.data,
                    borderWidth: 1.5,                // dünner
                    borderColor: 'rgba(239,68,68,0.3)', // rot mit hoher Transparenz
                    borderDash: [6, 6],              // gestrichelt
                    pointRadius: 0,                  // keine Punkte
                    fill: false,
                    tension: 0.1
                };
            } else if (ds.label === 'Optimistisch') {
                return {
                    label: ds.label,
                    data: ds.data,
                    borderWidth: 1.5,                // dünner
                    borderColor: 'rgba(34,197,94,0.3)', // grün mit hoher Transparenz
                    borderDash: [6, 6],              // gestrichelt
                    pointRadius: 0,                  // keine Punkte
                    fill: false,
                    tension: 0.1
                };
            } else {
                // Erwartet (blue), Einzahlungen (gray dashed): unchanged
                return {
                    label: ds.label,
                    data: ds.data,
                    borderColor: ds.color,
                    borderDash: ds.label.includes('Einzahlungen') ? [5, 5] : [],
                    fill: false,
                    tension: 0.1
                };
            }
        });

        prognoseChartInstance = new Chart(ctx, {
            type: 'line', data: { labels: labels, datasets: chartDatasets },
            options: { responsive: true, plugins: { legend: { labels: { color: '#d1d5db' } }, tooltip: { callbacks: { label: (c) => `${c.dataset.label}: ${formatCurrency(c.raw)}` } } },
                scales: { x: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { ticks: { color: '#9ca3af', callback: (v) => formatCurrency(v) }, grid: { color: 'rgba(255,255,255,0.1)' } } }
            }
        });
    }

    // --- Other Helpers ---
    function setRendite(value) { inputs.rendite.value = value; }
    
    function getRenditeDataForPeriod(jahre) {
        const key = [1, 5, 10, 15, 20, 25, 30].reduce((prev, curr) => (Math.abs(curr - jahre) < Math.abs(prev - jahre) ? curr : prev));
        return renditeData[key];
    }

    function updateRenditeSuggestions(jahre) {
      let data = null;
      if (renditeExtremes && renditeExtremes[jahre]) {
        data = renditeExtremes[jahre];
      } else {
        data = getRenditeDataForPeriod(jahre); // Fallback (grob)
      }
      const infoEl = getEl('rendite-info');
      const mid = ((data.min + data.max) / 2).toFixed(1);
      inputs.rendite.value = mid;

      // Farb-Logik: <0 rot, 0–3 gelb, >3 grün (pro Zahl separat)
      const colorClass = (v) => (v < 0 ? 'text-red-400' : (v < 3 ? 'text-yellow-400' : 'text-green-400'));
      const minSpan = `<span class="font-bold ${colorClass(data.min)}">${data.min}%</span>`;
      const maxSpan = `<span class="font-bold ${colorClass(data.max)}">${data.max}%</span>`;

      // Kein Quellhinweis mehr anzeigen
      infoEl.innerHTML = `Historische Spanne p.a.: ${minSpan} bis ${maxSpan}`;
    }

    function createGrowthChartSVG() { return `<svg viewBox="0 0 100 60" class="w-20 h-12 mb-1"><rect x="10" y="40" width="15" height="20" fill="#3b82f6" opacity="0.6"></rect><rect x="30" y="30" width="15" height="30" fill="#3b82f6" opacity="0.8"></rect><rect x="50" y="20" width="15" height="40" fill="#3b82f6"></rect><rect x="70" y="10" width="15" height="50" fill="#6366f1"></rect></svg>`; }
    function calculateOverflow(inflow, current, limit) { if (limit <= 0) return { tagesgeldInflow: inflow, depotOverflow: 0 }; const potential = current + inflow; if (potential <= limit) return { tagesgeldInflow: inflow, depotOverflow: 0 }; const overflow = potential - limit; return { tagesgeldInflow: inflow - overflow, depotOverflow: overflow }; }
    function openModal(modalId) { getEl(modalId).classList.add('modal-active'); }
    function closeModal(modalId) { getEl(modalId).classList.remove('modal-active'); }
    const fixkostenModal = { list: getEl('fixkosten-list'), total: getEl('modal-total') };
    function saveFixkosten() { calculateAndUpdate(); closeModal('fixkosten-modal'); }
    function renderFixkostenList() { fixkostenModal.list.innerHTML = ''; let total = 0; fixkostenItems.forEach((item, index) => { const itemEl = document.createElement('div'); itemEl.className = 'grid grid-cols-12 gap-2 items-center'; itemEl.innerHTML = `<input type="text" value="${item.name}" onchange="updateFixkostenItem(${index}, 'name', this.value)" placeholder="Posten" class="col-span-4 bg-gray-700 p-1 rounded"><input type="number" value="${item.amount}" onchange="updateFixkostenItem(${index}, 'amount', this.value)" placeholder="Betrag" class="col-span-2 bg-gray-700 p-1 rounded"><select onchange="updateFixkostenItem(${index}, 'interval', this.value)" class="col-span-2 bg-gray-700 p-1 rounded">${['monthly','quarterly','annually'].map(i => `<option value="${i}" ${item.interval === i ? 'selected' : ''}>${i==='monthly'?'mtl.':i==='quarterly'?'viertelj.':'jährl.'}</option>`).join('')}</select><select onchange="updateFixkostenItem(${index}, 'target', this.value)" class="col-span-3 bg-gray-700 p-1 rounded"><option value="fixkosten" ${item.target==='fixkosten'?'selected':''}>-> Fixkosten</option><option value="depot" ${item.target==='depot'?'selected':''}>-> Sparplan</option></select><button onclick="removeFixkostenItem(${index})" class="col-span-1 text-red-400 hover:text-red-300 text-xl">&times;</button>`; fixkostenModal.list.appendChild(itemEl); total += getMonthlyAmount(item); }); fixkostenModal.total.textContent = formatCurrency(total); }
function updateFixkostenItem(index, key, value) {
  // Normalize types per field
  if (key === 'amount') {
    value = parseFloat(value);
    if (!Number.isFinite(value)) value = 0;
    if (value < 0) value = 0; // no negative amounts
  }
  // Persist change in model
  if (fixkostenItems[index]) {
    fixkostenItems[index][key] = value;
  }
  // Re-render modal list & totals immediately
  renderFixkostenList();
}
    function addFixkostenItem() { fixkostenItems.push({ name: '', amount: 0, interval: 'monthly', target: 'fixkosten' }); renderFixkostenList(); }
    function removeFixkostenItem(index) { fixkostenItems.splice(index, 1); renderFixkostenList(); }
    const depotModal = { list: getEl('depot-list'), total: getEl('depot-total'), warning: getEl('depot-warning'), saveButton: getEl('depot-save-button') };
    function saveDepot() { if(checkDepotTotal()) { calculateAndUpdate(); closeModal('depot-modal'); } }
    function renderDepotList() { depotModal.list.innerHTML = ''; let total = 0; depotItems.forEach((item, index) => { total += item.allocation; const itemEl = document.createElement('div'); itemEl.className = 'grid grid-cols-12 gap-2 items-center'; itemEl.innerHTML = `<input type="color" value="${item.color}" onchange="updateDepotItem(${index}, 'color', this.value)" class="col-span-1 h-8 bg-gray-700 p-0 rounded"><input type="text" value="${item.name}" onchange="updateDepotItem(${index}, 'name', this.value)" placeholder="Fonds / ETF Name" class="col-span-7 bg-gray-700 p-1 rounded"><div class="relative col-span-3"><input type="number" value="${item.allocation}" onchange="updateDepotItem(${index}, 'allocation', this.value)" class="w-full text-right pr-6 bg-gray-700 p-1 rounded"><span class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400">%</span></div><button onclick="removeDepotItem(${index})" class="col-span-1 text-red-400 hover:text-red-300 text-xl">&times;</button>`; depotModal.list.appendChild(itemEl); }); checkDepotTotal(); }
    function updateDepotItem(index, key, value) { if (key === 'allocation') value = parseInt(value, 10) || 0; depotItems[index][key] = value; renderDepotList(); }
    function addDepotItem() { depotItems.push({ name: '', allocation: 0, color: '#'+Math.floor(Math.random()*16777215).toString(16) }); renderDepotList(); }
    function removeDepotItem(index) { depotItems.splice(index, 1); renderDepotList(); }
    function checkDepotTotal() { const total = depotItems.reduce((sum, i) => sum + i.allocation, 0); depotModal.total.textContent = `${total} %`; if (total === 100) { depotModal.total.className = "text-2xl font-bold text-green-400"; depotModal.warning.textContent = ""; depotModal.saveButton.disabled = false; depotModal.saveButton.classList.remove('opacity-50', 'cursor-not-allowed'); return true; } else { depotModal.total.className = "text-2xl font-bold text-red-400"; depotModal.warning.textContent = "Die Summe der Verteilung muss 100% ergeben."; depotModal.saveButton.disabled = true; depotModal.saveButton.classList.add('opacity-50', 'cursor-not-allowed'); return false; } }

    // --- Helpers: Export current SVG flow and Chart.js chart as images ---
    async function svgToPngDataUrl(svgElement, scale = 2, bg = '#ffffff') {
      const rect = svgElement.getBoundingClientRect();

      // 1) Clone the on-screen SVG so we can preprocess without affecting UI
      const clone = svgElement.cloneNode(true);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      clone.setAttribute('width', rect.width);
      clone.setAttribute('height', rect.height);
      clone.removeAttribute('style');

      // 2) Remove mask for export (avoids black rectangle in rasterization)
      const visuals = clone.querySelector('#flow-visuals');
      if (visuals) visuals.removeAttribute('mask');

      // 3) Inject background rect (theme-aware)
      const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bgRect.setAttribute('x', '0');
      bgRect.setAttribute('y', '0');
      bgRect.setAttribute('width', '100%');
      bgRect.setAttribute('height', '100%');
      bgRect.setAttribute('fill', bg);
      clone.insertBefore(bgRect, clone.firstChild);

      // 4) Inline stroke colors on cloned paths (in case CSS vars don't carry over)
      try {
        const originalPaths = svgElement.querySelectorAll('.flow-path, .flow-path-animation, .flow-erase');
        const clonedPaths   = clone.querySelectorAll('.flow-path, .flow-path-animation, .flow-erase');
        clonedPaths.forEach((node, i) => {
          const src = originalPaths[i];
          if (!src) return;
          const cs = getComputedStyle(src);
          if (cs && cs.stroke && cs.stroke !== 'none') node.setAttribute('stroke', cs.stroke);
        });
      } catch (_) {}

      // 5) Serialize the prepared clone and draw it onto a canvas
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(clone);
      const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(800, Math.floor(rect.width * scale));
      canvas.height = Math.max(600, Math.floor(rect.height * scale));

      const ctx = canvas.getContext('2d');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      await new Promise((resolve, reject) => {
        img.onload = () => {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          URL.revokeObjectURL(url);
          resolve();
        };
        img.onerror = reject;
        img.src = url;
      });

      return canvas.toDataURL('image/png');
    }
    function getFlowSnapshotDataUrl() {
      const svg = document.getElementById('flow-svg');
      if (!svg) return null;
      return svgToPngDataUrl(svg, 2, '#ffffff');
    }
    function getChartImageDataUrl() {
      // existierende Instanz nutzen
      if (prognoseChartInstance && typeof prognoseChartInstance.toBase64Image === 'function') {
        try { return prognoseChartInstance.toBase64Image('image/png', 1.0); } catch (_) {}
      }
      // Fallback: temporären Chart rendern
      try {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1000;
        tempCanvas.height = 420;
        const ctx = tempCanvas.getContext('2d');

        const years = parseInt(inputs.anlagezeitraum.value, 10) || 15;
        const dataRange = (renditeExtremes && renditeExtremes[years]) || getRenditeDataForPeriod(years);
        const initialDepot = parseFloat(inputs.depotCurrent.value) || 0;

        const depotSparplanTotal = fixkostenItems
          .filter(i => i.target === 'depot')
          .reduce((s, it) => s + getMonthlyAmount(it), 0);

        const { depotOverflow } = calculateOverflow(
          parseFloat(inputs.tagesgeldCurrent.value) || 0,
          parseFloat(inputs.tagesgeldLimit.value) || 0
        );
        const monthlyInvestment = depotSparplanTotal + depotOverflow;

        const toSeries = (rate) => calculateCompoundInterest(initialDepot, monthlyInvestment, years, rate / 100);
        const sMin = toSeries(dataRange.min);
        const sAvg = toSeries(((dataRange.min + dataRange.max) / 2));
        const sMax = toSeries(dataRange.max);

        const tmpChart = new Chart(ctx, {
          type: 'line',
          data: { labels: sAvg.labels, datasets: [
            { label: 'Pessimistisch', data: sMin.capitalData, borderColor: '#ef4444', fill: false, tension: 0.1 },
            { label: 'Erwartet',      data: sAvg.capitalData, borderColor: '#3b82f6', fill: false, tension: 0.1 },
            { label: 'Optimistisch',  data: sMax.capitalData, borderColor: '#22c55e', fill: false, tension: 0.1 }
          ]},
          options: { responsive: false, animation: false, plugins: { legend: { display: false } } }
        });
        // Sicherstellen, dass gezeichnet wurde
        tmpChart.update();
        const url = tempCanvas.toDataURL('image/png');
        tmpChart.destroy();
        return url;
      } catch (_) {
        return null;
      }
    }

    // Helper: wait for one or more animation frames (lets layout/theme settle)
    async function waitFrames(n = 1) {
      for (let i = 0; i < n; i++) {
        await new Promise(res => requestAnimationFrame(res));
      }
    }

    async function waitForImages(container, timeout = 2500) {
      const imgs = Array.from(container.querySelectorAll('img'));
      const pending = imgs.filter(img => !img.complete || img.naturalWidth === 0);

      if (pending.length === 0) return;

      await Promise.race([
        Promise.all(pending.map(img => new Promise(res => {
          img.addEventListener('load', res, { once: true });
          img.addEventListener('error', res, { once: true }); // not blocking on error
          // Falls das Bild bereits „complete“ ist, sofort auflösen:
          if (img.complete && img.naturalWidth > 0) res();
        }))),
        new Promise(res => setTimeout(res, timeout))
      ]);
    }

    
    function buildBookingPlanPrintHtml() {
        const plan = bookingPlan || {};
        const bucket = plan[String(selectedBookingMonth)] || plan[BOOKING_KEY] || {};
        const days = Object.keys(bucket)
            .map(key => parseInt(key, 10))
            .filter(num => Number.isInteger(num))
            .sort((a, b) => a - b);
        if (!days.length) {
            return `
      <h2>Buchungskalender</h2>
      <p class="muted">Aktuell sind keine Buchungstage hinterlegt.</p>
    `;
        }
        const rows = days.map(dayNum => {
            const key = String(dayNum);
            const entries = Array.isArray(bucket[key]) ? bucket[key] : [];
            const content = entries
                .map(typeId => {
                    const type = getBookingType(typeId);
                    if (!type) return '';
                    const color = type.badgeColor || '#111827';
                    return `<div class="print-booking-entry"><span class="print-booking-icon" style="color:${color};">${type.icon}</span><span>${type.label}</span></div>`;
                })
                .filter(Boolean)
                .join('') || '<div class="print-booking-entry">-</div>';
            return `<tr><td>Tag ${dayNum}</td><td>${content}</td></tr>`;
        }).join('');
        return `<h2>Buchungskalender</h2><table class="print-table print-table-bookings"><thead><tr><th>Tag</th><th>Aktion</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    async function prepareAndPrint() {
        const report = getEl('printable-report');

        // --- Force LIGHT THEME for export/print snapshot ---
        const prevTheme = loadTheme();           // 'dark' | 'light'
        applyTheme('light');                     // switch UI tokens
        saveTheme('light');
        // Re-render flows so computed styles & erase strokes match light mode
        calculateAndUpdate();
        await waitFrames(2);                     // let DOM/layout settle

        const themeNote = 'MLP Hell';

        // 1) Gather current inputs (after potential UI changes)
        const incomeVal = formatCurrency(inputs.income.value);
        const konsumMinVal = formatCurrency(inputs.konsumMin.value);
        const konsumLeftoverVal = formatCurrency(inputs.konsumLeftover.value);
        const tgCurVal = formatCurrency(inputs.tagesgeldCurrent.value);
        const tgLimitVal = formatCurrency(inputs.tagesgeldLimit.value);
        const depotCurVal = formatCurrency(inputs.depotCurrent.value);
        const jahre = parseInt(inputs.anlagezeitraum.value, 10);
        const renditeAnn = parseFloat(inputs.rendite.value).toFixed(1) + ' %';

        // 2) Export visualizations (always white background)
        const flowImg = await svgToPngDataUrl(getEl('flow-svg'), 2, '#ffffff');
        const chartImg = getChartImageDataUrl();

        // 3) Build Fixkosten & Depot tables
        const fixRows = fixkostenItems.map(i => `<tr><td>${i.name}</td><td>${formatCurrency(i.amount)}</td><td>${i.interval}</td><td>${i.target}</td></tr>`).join('');
        const depRows = depotItems.map(i => `<tr><td>${i.name}</td><td>${i.allocation}%</td></tr>`).join('');

        // 4) Compose report HTML (theme-neutral for print)
        let html = `
          <h1>Zusammenfassung: Das intelligente Vermögensmanagement</h1>
          <p class="muted">Variante: <strong>${currentVariant}</strong> • Theme: <strong>${themeNote}</strong> • Datum: ${new Date().toLocaleDateString('de-DE')}</p>

          <h2>Ihre Planung</h2>
          <table class="print-table">
            <tbody>
              <tr><th style="width:40%">Nettoeinkommen</th><td>${incomeVal}</td></tr>
              <tr><th>Konsumkonto Mindestbestand</th><td>${konsumMinVal}</td></tr>
              <tr><th>Geschätzter monatlicher Überschuss</th><td>${konsumLeftoverVal}</td></tr>
              <tr><th>Tagesgeldkonto (aktuell)</th><td>${tgCurVal}</td></tr>
              <tr><th>Tagesgeldkonto (Sparziel)</th><td>${tgLimitVal}</td></tr>
              <tr><th>Depotstand (aktuell)</th><td>${depotCurVal}</td></tr>
              <tr><th>Anlagezeitraum</th><td>${jahre} Jahre</td></tr>
              <tr><th>Rendite-Annahme</th><td>${renditeAnn}</td></tr>
            </tbody>
          </table>

          <h2>Fixkosten &amp; Sparpläne</h2>
          <table class="print-table"><thead><tr><th>Posten</th><th>Betrag</th><th>Intervall</th><th>Ziel</th></tr></thead><tbody>${fixRows}</tbody></table>
          <div class="print-break"></div>

          <h2>Depot-Aufteilung</h2>
          <table class="print-table"><thead><tr><th>Fonds/ETF</th><th>Verteilung</th></tr></thead><tbody>${depRows}</tbody></table>
        `;
        html += buildBookingPlanPrintHtml(); // (Überschrift wird unten im <section> gesetzt)
        report.innerHTML = html;

        // Eigene Seite vorbereiten
        const section = document.createElement('section');
        section.className = 'print-finanzfluss';
        // Fallbacks für Browser, die die CSS-Regel ignorieren
        section.style.breakBefore = 'page';
        section.style.pageBreakBefore = 'always';
        section.innerHTML = `<h2>Dein Finanzfluss (aktueller Stand)</h2>`;

        // Live-DOM klonen: Ströme + Konten + Werte
        const live = getEl('flow-container');
        if (live) {
          const clone = live.cloneNode(true);
          clone.id = 'flow-container-print';

          // Interaktivität entfernen (keine Modals im Print)
          clone.querySelectorAll('[onclick]').forEach(n => n.removeAttribute('onclick'));

          // Deterministische Größe wie im Live-UI
          const cs = getComputedStyle(live);
          clone.style.position = 'relative';
          clone.style.minHeight = cs.minHeight || '1150px';
          clone.style.height    = cs.height || '1150px';
          clone.style.width     = '100%';

          const holder = document.createElement('div');
          holder.style.marginTop = '8px';
          holder.appendChild(clone);
          section.appendChild(holder);
        }

        // Abschnitt (eigene Seite) anhängen
        report.appendChild(section);

        // NEU: sicherstellen, dass die <img>-Tags wirklich fertig sind
        await waitForImages(report, 2500);
        await waitFrames(1); // ein Frame für Layout

        // 5) Print
        const restoreTheme = () => {
          applyTheme(prevTheme || 'dark');
          saveTheme(prevTheme || 'dark');
          calculateAndUpdate();
        };
        const onAfterPrint = () => { window.removeEventListener('afterprint', onAfterPrint); restoreTheme(); };
        window.addEventListener('afterprint', onAfterPrint);
        window.print();
    }
    
    // --- THEME HANDLING (Dark/MLP Light) ---
    function applyTheme(theme) {
        const root = document.getElementById('theme-root');
        if (!root) return;
        root.classList.remove('theme-dark','theme-light');
        root.classList.add(theme === 'light' ? 'theme-light' : 'theme-dark');

        // Flow gradient colors adapt to theme
        const grad = document.querySelector('#flow-gradient');
        if (grad) {
            const stops = grad.querySelectorAll('stop');
            if (stops.length >= 2) {
                if (theme === 'light') {
                    // Pure MLP blue stream
                    stops[0].setAttribute('style', 'stop-color: var(--mlp-blue-1);');
                    stops[1].setAttribute('style', 'stop-color: var(--mlp-blue-1);');
                } else {
                    // force classic dark gradient
                    stops[0].setAttribute('style', 'stop-color: #3b82f6;');
                    stops[1].setAttribute('style', 'stop-color: #6366f1;');
                }
            }
        }
    }
    function loadTheme() {
        try { return localStorage.getItem('vd_theme') || 'dark'; } catch(_) { return 'dark'; }
    }
    function saveTheme(theme) {
        try { localStorage.setItem('vd_theme', theme); } catch(_) {}
    }

    // INITIALIZATION
    document.addEventListener('DOMContentLoaded', () => {
        inputs = { income: getEl('income'), konsumMin: getEl('konsumMin'), konsumLeftover: getEl('konsumLeftover'), tagesgeldCurrent: getEl('tagesgeldCurrent'), tagesgeldLimit: getEl('tagesgeldLimit'), depotCurrent: getEl('depotCurrent'), anlagezeitraum: getEl('anlagezeitraum'), rendite: getEl('rendite') };
        basins = { gehalt: getEl('gehalt-basin'), fixkosten: getEl('fixkosten-basin'), konsum: getEl('konsum-basin'), tagesgeld: getEl('tagesgeld-basin'), depot: getEl('depot-basin') };
        flowContainer = getEl('flow-container');
        setupBookingPlanner();

        // THEME init
        const themeSwitch = getEl('theme-switch');
        const initialTheme = loadTheme(); // 'dark' | 'light'
        applyTheme(initialTheme);
        if (themeSwitch) {
            // checked == Dark (rechts), unchecked == MLP Light (links)
            themeSwitch.checked = (initialTheme === 'dark');
            themeSwitch.addEventListener('change', (e) => {
                const t = e.target.checked ? 'dark' : 'light';
                applyTheme(t);
                saveTheme(t);
                // Nach Themewechsel neu zeichnen
                calculateAndUpdate();
            });
        }

        const anlagezeitraumLabel = getEl('anlagezeitraum-label');
        const variantSwitch = getEl('variant-switch');
        const varianteALabel = getEl('variante-a-label');
        const varianteBLabel = getEl('variante-b-label');
        const variantInfo = getEl('variant-info');

        function setVariantUI() {
            if (variantSwitch) {
                variantSwitch.checked = (currentVariant === 'B');
            }
            if (currentVariant === 'A') {
                varianteALabel.classList.add('chip-state--active');
                varianteBLabel.classList.remove('chip-state--active');
                if (variantInfo) variantInfo.textContent = 'Variante A: Gehalt geht auf das Fixkostenkonto.';
            } else {
                varianteBLabel.classList.add('chip-state--active');
                varianteALabel.classList.remove('chip-state--active');
                if (variantInfo) variantInfo.textContent = 'Variante B: Gehalt geht auf das Konsumkonto.';
            }
            // Keep consultation view consistent when variant changes
            applyConsultationVisibility();
            calculateAndUpdate();
        }

        variantSwitch.addEventListener('change', (e) => {
            currentVariant = e.target.checked ? 'B' : 'A';
            setVariantUI();
        });

        inputs.anlagezeitraum.addEventListener('input', (e) => {
            const jahre = parseInt(e.target.value, 10);
            anlagezeitraumLabel.textContent = `${jahre} Jahre`;
            updateRenditeSuggestions(jahre);
        });
        
        const observer = new ResizeObserver(() => calculateAndUpdate());
        observer.observe(flowContainer);
        
        setTimeout(() => {
            renderFixkostenList();
            renderDepotList();
            setVariantUI();
            updateRenditeSuggestions(parseInt(inputs.anlagezeitraum.value, 10));
            calculateAndUpdate();

            // Load fine-grained min/max ranges from TXT (MLP-Dreieck)
            loadRenditeExtremes();

            // Keep info live while sliding
            inputs.anlagezeitraum.addEventListener('input', () => {
                const jahre = parseInt(inputs.anlagezeitraum.value, 10);
                const label = getEl('anlagezeitraum-label');
                if (label) label.textContent = `${jahre} Jahre`;
                updateRenditeSuggestions(jahre);
            });

            // Beratungsansicht Buttons
            const consultToggle = getEl('consult-toggle-btn');
            const consultNext   = getEl('consult-next-btn');
            if (consultToggle) consultToggle.addEventListener('click', () => setConsultationMode(!consultationMode));
            if (consultNext)   consultNext.addEventListener('click', () => nextConsultationStep());
        }, 100);
    });
    </script>
    <script src="scripts/a11y.js" defer></script>
    <script src="scripts/autoRecalc.js" defer></script>
    <script src="scripts/variantFix.js" defer></script>
    <script src="scripts/reloadButton.js" defer></script>
    <script src="scripts/recalcFab.js" defer></script>
    <script src="scripts/removeHeaderIcon.js" defer></script>
</body>
</html>


